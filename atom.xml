<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZHY的hexo博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-30T05:32:55.440Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iotZHY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pysot的配置安装</title>
    <link href="http://yoursite.com/2020/11/30/pysot%E7%9A%84%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2020/11/30/pysot的配置安装/</id>
    <published>2020-11-30T02:40:53.000Z</published>
    <updated>2020-11-30T05:32:55.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>最近做项目时用到的效果很好的目标跟踪算法，在windows上运行时，遇到了一些问题，在此记录。<br>官方Github：<a href="https://github.com/STVIR/pysot" target="_blank" rel="noopener">pysot</a><br><a id="more"></a></p><h3 id="配置与安装"><a href="#配置与安装" class="headerlink" title="配置与安装"></a>配置与安装</h3><h4 id="Windows下搭环境（建议用anaconda）"><a href="#Windows下搭环境（建议用anaconda）" class="headerlink" title="Windows下搭环境（建议用anaconda）"></a>Windows下搭环境（建议用anaconda）</h4><h5 id="Create-environment-and-activate"><a href="#Create-environment-and-activate" class="headerlink" title="Create environment and activate"></a>Create environment and activate</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create --name pysot python=3.7</span><br><span class="line">conda activate pysot</span><br></pre></td></tr></table></figure><h5 id="Install-numpy-pytorch-opencv"><a href="#Install-numpy-pytorch-opencv" class="headerlink" title="Install numpy/pytorch/opencv"></a>Install numpy/pytorch/opencv</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy</span><br><span class="line">conda install pytorch=0.4.1 torchvision cuda90 -c pytorch</span><br><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h5 id="Install-other-requirements"><a href="#Install-other-requirements" class="headerlink" title="Install other requirements"></a>Install other requirements</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyyaml yacs tqdm colorama matplotlib cython tensorboardX</span><br></pre></td></tr></table></figure><h5 id="Build-extensions"><a href="#Build-extensions" class="headerlink" title="Build extensions"></a>Build extensions</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure><h4 id="Linux下搭建"><a href="#Linux下搭建" class="headerlink" title="Linux下搭建"></a>Linux下搭建</h4><p>因为我是在windows环境下，我没用使用install.sh脚本文件，在linux环境下可以通过install.sh快速配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash install.sh /path/to/your/conda pysot</span><br></pre></td></tr></table></figure><h4 id="下载模型"><a href="#下载模型" class="headerlink" title="下载模型"></a>下载模型</h4><p>在<a href>PySOT Model Zoo</a>下载模型，并放到experiments文件夹下对应的文件夹里面，注意experiments里的config文件不要覆盖。</p><h4 id="运行demo"><a href="#运行demo" class="headerlink" title="运行demo"></a>运行demo</h4><p>这是我在PyCharm里的配置<br><img src="/2020/11/30/pysot的配置安装/01.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--config</span><br><span class="line">../experiments/siammaske_r50_l3/config.yaml</span><br><span class="line">--snapshot</span><br><span class="line">../experiments/siammaske_r50_l3/model.pth</span><br><span class="line">--video</span><br><span class="line">../demo/自己的视频文件</span><br></pre></td></tr></table></figure></p><h4 id="下载测试数据集"><a href="#下载测试数据集" class="headerlink" title="下载测试数据集"></a>下载测试数据集</h4><ul><li>OTB100数据集<br>链接：<a href="https://pan.baidu.com/s/1gU0FBEWhREc1Ik6dKir26A" target="_blank" rel="noopener">https://pan.baidu.com/s/1gU0FBEWhREc1Ik6dKir26A</a><br>提取码：zhy8 </li><li>Jsons格式<br><a href="https://pan.baidu.com/s/1js0Qhykqqur7_lNRtle1tA#list/path=%2F" target="_blank" rel="noopener">百度云</a>或者<a href="https://drive.google.com/drive/folders/10cfXjwQQBQeu48XMf2xc_W1LucpistPI" target="_blank" rel="noopener">Google Driver</a></li></ul><p>我们需要把OTB100数据集，放入testing_dataset文件夹下。</p><p>还需要对OTB100数据集进行一些修改，才能符合测试数据集的要求，看官方给我们的操作方法：<br><img src="/2020/11/30/pysot的配置安装/02.png" alt><br>意思是我们需要把CVRP13.json, OTB100.json, OTB50.json这三个文件放入OTB100中，且把Jogging文件夹复制两份命名成Jogging-1和Jogging-2，把Skating2复制两个变成Skating2-1和Skating2-2。</p><p>除了官方给的，我还需要修改Human4为Human4-2，且这些修改都是根据OTB100.json。</p><p>同时还需要注意的一点是项目的路径上不能有中文，会报错。</p><h4 id="运行test"><a href="#运行test" class="headerlink" title="运行test"></a>运行test</h4><p>PyCharm的配置：<br><img src="/2020/11/30/pysot的配置安装/03.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--snapshot</span><br><span class="line">../experiments/siamrpn_r50_l234_dwxcorr/model.pth</span><br><span class="line">--dataset</span><br><span class="line">OTB100</span><br><span class="line">--config</span><br><span class="line">../experiments/siamrpn_r50_l234_dwxcorr/config.yaml</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;最近做项目时用到的效果很好的目标跟踪算法，在windows上运行时，遇到了一些问题，在此记录。&lt;br&gt;官方Github：&lt;a href=&quot;https://github.com/STVIR/pysot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pysot&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标追踪" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>入门计算机视觉</title>
    <link href="http://yoursite.com/2020/11/22/%E5%85%A5%E9%97%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    <id>http://yoursite.com/2020/11/22/入门计算机视觉/</id>
    <published>2020-11-22T08:27:25.000Z</published>
    <updated>2020-11-22T09:25:51.038Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CG、CV、DIP的区别与联系"><a href="#CG、CV、DIP的区别与联系" class="headerlink" title="CG、CV、DIP的区别与联系"></a>CG、CV、DIP的区别与联系</h4><h5 id="1-区别"><a href="#1-区别" class="headerlink" title="(1)区别"></a>(1)区别</h5><p>计算机图形学（Computer Graphics），简称 CG 。输入的是对虚拟场景的描述，通常为多边形数组，而每个多边形由三个顶点组成，每个顶点包括三维坐标、贴图坐标、rgb 颜色等。输出的是图像，即二维像素数组。</p><p>计算机视觉（Computer Vision），简称 CV。输入的是图像或图像序列，通常来自相机、摄像头或视频文件。输出的是对于图像序列对应的真实世界的理解，比如检测人脸、识别车牌。</p><p>数字图像处理（Digtal Image Processing），简称 DIP。输入的是图像，输出的也是图像。Photoshop 中对一幅图像应用滤镜就是典型的一种图像处理。常见操作有模糊、灰度化、增强对比度等。</p><p>即CG是抽象语义-&gt;图像，CV是图像-&gt;抽象语义，DIP是图像-&gt;图像<br><a id="more"></a></p><h5 id="2-联系"><a href="#2-联系" class="headerlink" title="(2)联系"></a>(2)联系</h5><p>CG 中也会用到 DIP，现今的三维游戏为了增加表现力都会叠加全屏的后期特效，原理就是 DIP，只是将计算量放在了显卡端。</p><p>CV 更是大量依赖 DIP 来打杂活，比如对需要识别的照片进行预处理。</p><p>最后还要提到近年来的热点——增强现实（AR），它既需要 CG，又需要 CV，当然也不会漏掉 DIP。它用 DIP 进行预处理，用 CV 进行跟踪物体的识别与姿态获取，用 CG 进行虚拟三维物体的叠加。</p><p><img src="/2020/11/22/入门计算机视觉/1.jpg" alt></p><h4 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h4><h5 id="需要的知识"><a href="#需要的知识" class="headerlink" title="需要的知识"></a>需要的知识</h5><ul><li>编程语言：C/C++，Python</li><li>数学功底：线性代数</li><li>数字图像处理</li><li>机器学习</li><li><p>深度学习</p><h5 id="好的资源（书籍和视频资源）"><a href="#好的资源（书籍和视频资源）" class="headerlink" title="好的资源（书籍和视频资源）"></a>好的资源（书籍和视频资源）</h5><p>书籍：</p></li><li><p>冈萨雷斯的《数字图像处理》</p></li><li><p>西瓜书<br><a href="https://link.zhihu.com/?target=https%3A//github.com/datawhalechina/pumpkin-book" target="_blank" rel="noopener">代码实现</a></p></li><li><p>花书</p></li></ul><p>视频：</p><p><a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html" target="_blank" rel="noopener">麻省理工线性代数</a><br><a href="https://study.163.com/course/courseLearn.htm?courseId=1004570029" target="_blank" rel="noopener">吴恩达机器学习</a><br><a href="https://www.bilibili.com/video/BV1nJ411z7fe/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">斯坦福大学的CS231N课程</a><br><a href="https://www.bilibili.com/video/BV1JE411g7XF/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">李宏毅2020机器学习深度学习(完整版)国语</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;CG、CV、DIP的区别与联系&quot;&gt;&lt;a href=&quot;#CG、CV、DIP的区别与联系&quot; class=&quot;headerlink&quot; title=&quot;CG、CV、DIP的区别与联系&quot;&gt;&lt;/a&gt;CG、CV、DIP的区别与联系&lt;/h4&gt;&lt;h5 id=&quot;1-区别&quot;&gt;&lt;a href=&quot;#1-区别&quot; class=&quot;headerlink&quot; title=&quot;(1)区别&quot;&gt;&lt;/a&gt;(1)区别&lt;/h5&gt;&lt;p&gt;计算机图形学（Computer Graphics），简称 CG 。输入的是对虚拟场景的描述，通常为多边形数组，而每个多边形由三个顶点组成，每个顶点包括三维坐标、贴图坐标、rgb 颜色等。输出的是图像，即二维像素数组。&lt;/p&gt;
&lt;p&gt;计算机视觉（Computer Vision），简称 CV。输入的是图像或图像序列，通常来自相机、摄像头或视频文件。输出的是对于图像序列对应的真实世界的理解，比如检测人脸、识别车牌。&lt;/p&gt;
&lt;p&gt;数字图像处理（Digtal Image Processing），简称 DIP。输入的是图像，输出的也是图像。Photoshop 中对一幅图像应用滤镜就是典型的一种图像处理。常见操作有模糊、灰度化、增强对比度等。&lt;/p&gt;
&lt;p&gt;即CG是抽象语义-&amp;gt;图像，CV是图像-&amp;gt;抽象语义，DIP是图像-&amp;gt;图像&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>数据挖掘-多路数组聚集</title>
    <link href="http://yoursite.com/2020/05/21/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E5%A4%9A%E8%B7%AF%E6%95%B0%E7%BB%84%E8%81%9A%E9%9B%86/"/>
    <id>http://yoursite.com/2020/05/21/数据挖掘-多路数组聚集/</id>
    <published>2020-05-21T14:58:10.000Z</published>
    <updated>2020-07-23T08:15:05.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>刚刚在写作业时，遇到了多路数组聚集的题，这块没太弄明白，故费了好大的劲，终于想明白。特地记下，方便以后查看。<br><a id="more"></a></p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一道类似的题：<br>基本立方体有三维A，B，C，其单元数分别为40，400，4000，每维均等分成4块，且一个立方体单元存储度量需要4byte</p><p>1）维度聚集的顺序？<br>2）计算2-D立方体，所需的最小的内存需要？</p><h3 id="了解多路数组聚集"><a href="#了解多路数组聚集" class="headerlink" title="了解多路数组聚集"></a>了解多路数组聚集</h3><p>计算多路数组聚集问题所需注意的：</p><ul><li><p>尽量减少块反复调入内存的次数。</p></li><li><p>尽量利用较少的内存空间完成计算。</p></li></ul><p>该算法的核心是：“用一个二维数组缓存一个2-D立方体的计算结果”。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目给定的场景是，把一个基本立方体分成了4x4x4=64块，每块大小10x100x1000。每次读入一个块，1-64块顺序读入。</p><p>首先，第一问，按照维度单元数从小到大聚集就可以了，至于为什么看完第二问的分析大概就能知道。</p><p>第二问，先看下图：<br><img src="/2020/05/21/数据挖掘-多路数组聚集/947970-20161130163740646-553541217.png" alt></p><p>图的大概意思就是，中间是一个被分成64份的基本立方体，边上的三个是它按照不同维度聚集的面。</p><p>因为A的单元数最少，所以先按A维度聚集，看BC面，读取第一块数据，计算机把它沿着A聚集，存入BC面的一个单元c1，这个单元大小（100x1000），接着第二块进入，它在上一步聚集的基础上，进一步聚集到c1，…,直到第4块读取完，只用这一个单元就读取了4个块，完后，就把这个单元的值存入磁盘，接着复用这一个单元，故沿A维度 ，最小占用内存是基本立方体BC面的1/16，也就是400x4000/16=100x1000，也是一个块的BC面的大小；</p><p>沿B维，由图可看出，只有读取完第13块，我们才能完整的得到一个AC面单元，所以之前的块也需要有内存空间来记录，故我们需要开辟4个AC面的单元，大小为基本立方体AC面的1/4，40x4000/4=4x10x1000,也是4个块的AC面； </p><p>沿C维，只有读完49块才能得到一个完整的AB面单元，故我们需要整个AB面的内存，40x400=16x10x100，也是16个块的AB面。</p><p>从上面的分析可以看出，越到后面，越需要更多块的面单元，因为我们需要占用最小的内存，所以我们需要按面单元大小降序进行聚集。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;刚刚在写作业时，遇到了多路数组聚集的题，这块没太弄明白，故费了好大的劲，终于想明白。特地记下，方便以后查看。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据挖掘" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
      <category term="专业课" scheme="http://yoursite.com/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件描述符</title>
    <link href="http://yoursite.com/2020/05/11/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/05/11/Linux文件描述符/</id>
    <published>2020-05-11T10:06:05.000Z</published>
    <updated>2020-07-23T08:28:06.662Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇转载自<a href="https://www.jianshu.com/p/5e29fea10f82" target="_blank" rel="noopener">https://www.jianshu.com/p/5e29fea10f82</a>的文章，成功为我解惑。<br><a id="more"></a></p><h3 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h3><p><img src="/2020/05/11/Linux文件描述符/1.webp" alt><br>1）进程级文件描述符表 Process File Table</p><p>2）系统级打开文件表 System File Table</p><p>3）系统i-Node表</p><h3 id="调用open函数会发生什么"><a href="#调用open函数会发生什么" class="headerlink" title="调用open函数会发生什么"></a>调用open函数会发生什么</h3><p><img src="/2020/05/11/Linux文件描述符/2.webp" alt><br>每次open时，会在进程文件描述符表新增数据（一个int型fd 和一个指针），指针指向系统打开文件表。系统文件表会表明这个打开文件的权限（status 读、写等），当前打开文件的偏移量（offset 即下次读取时的位置），指向系统i-Node表的指针等。因此我们可以知道，fd是针对进程的概念，不同进程的相同fd很大可能并没有任何关系</p><h3 id="对同一个文件打开多次会怎样"><a href="#对同一个文件打开多次会怎样" class="headerlink" title="对同一个文件打开多次会怎样"></a>对同一个文件打开多次会怎样</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Process A: </span><br><span class="line"></span><br><span class="line">fd1 = open(<span class="string">"/var/file1"</span>, O_RDONLY); </span><br><span class="line"></span><br><span class="line">fd2 = open(<span class="string">"/var/file2"</span>, O_RDWR); </span><br><span class="line"></span><br><span class="line">fd3 = open(<span class="string">"/var/file1"</span>, O_WRONLY);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Process B: </span><br><span class="line"></span><br><span class="line">fd1 = open(<span class="string">"/var/file1"</span>, O_RDONLY); </span><br><span class="line"></span><br><span class="line">fd2 = open(<span class="string">"/var/file3"</span>, O_RDONLY);</span><br></pre></td></tr></table></figure><p><img src="/2020/05/11/Linux文件描述符/3.webp" alt><br>不管是相同进程还是不同进程，只要调用open就会有一个新的fd和一个新的系统打开文件表的对应项，所以对这些fd进行读取操作并不会造成相互影响。因为系统文件表是独立的，offset也是独立的</p><h3 id="父子进程的文件关系"><a href="#父子进程的文件关系" class="headerlink" title="父子进程的文件关系"></a>父子进程的文件关系</h3><p><img src="/2020/05/11/Linux文件描述符/4.webp" alt><br>调用fork后，虽然父子进程都有独立的进程文件描述符表，但所有fd所对应的文件表都会保持完全一致，因此当我们在子进程读取fd1时，父进程的file offset也会同时变化，也就造成了一些奇怪的现象，所以对待fd的读写要谨慎处理</p><h3 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h3><p><img src="/2020/05/11/Linux文件描述符/5.webp" alt><br>dup2(close_this_fd = open(“my.txt”, O_WRONLY), 1);</p><p>程序的输出会直接输出到标准输出，但以上语句会将现有进程的标准输出（fd = 1）重定向到my.txt对应的文件表。因此输出后，my.txt将会展示刚才程序的输出。这也就是 out &gt; my.txt的实现</p><h3 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h3><p><img src="/2020/05/11/Linux文件描述符/6.webp" alt><br>管道的总体原理就是（ls | grep）</p><p>1）A/B两个进程，B进程是A的子进程，A进程执行ls ，B进程执行grep</p><p>2）将A进程的标准输出通过dup2命令重定向到一个buffer区</p><p>3）B进程的标准输入通过dup2重定向到同一个buffer区</p><p>4）B进程获取到A进程的输出并执行自己的逻辑</p><h3 id="转载自"><a href="#转载自" class="headerlink" title="转载自"></a>转载自</h3><p><a href="https://www.jianshu.com/p/5e29fea10f82" target="_blank" rel="noopener">文件系统之文件描述符</a></p><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://www.jianshu.com/p/cded914786d5" target="_blank" rel="noopener">Linux文件描述符</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一篇转载自&lt;a href=&quot;https://www.jianshu.com/p/5e29fea10f82&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/5e29fea10f82&lt;/a&gt;的文章，成功为我解惑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux编程——无名管道</title>
    <link href="http://yoursite.com/2020/05/11/Linux%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2020/05/11/Linux编程——无名管道/</id>
    <published>2020-05-11T09:17:49.000Z</published>
    <updated>2020-11-30T05:28:40.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编程目标"><a href="#编程目标" class="headerlink" title="编程目标"></a>编程目标</h3><p>利用编程模拟shell中的管道操作“ps -ef | wc -l”</p><h3 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h3><ul><li>int pipe(int pipe_fd[2]); //管道函数</li><li>int dup2(int oldfd, int newfd);<a id="more"></a><h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3></li></ul><p><img src="/2020/05/11/Linux编程——无名管道/20171021101043815.png" alt></p><ul><li>只能用于有亲缘关系的进程，因为子进程可以继承父进程的管道。</li><li>管道是一种特殊的文件，存在于内核的内存当中，不属于任何文件系统。</li><li>它是一个半双工的模式，但是一般我们只需要单工即可，关闭掉多余的文件描述符。<h3 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h3><img src="/2020/05/11/Linux编程——无名管道/14802069-e40633ee5c622c3d.webp" alt><br>dup2(close_this_fd = open(“my.txt”, O_WRONLY), 1);</li></ul><p>程序的输出会直接输出到标准输出，但以上语句会将现有进程的标准输出（fd = 1）重定向到my.txt对应的文件表。因此输出后，my.txt将会展示刚才程序的输出。这也就是 out &gt; my.txt的实现</p><h3 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a>管道的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fd_redirect</span><span class="params">(<span class="keyword">int</span> oldfd,<span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(pipe(pipe_fd)&lt;<span class="number">0</span>)&#123;  <span class="comment">//创建管道</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork create error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123; <span class="comment">//父进程</span></span><br><span class="line">        close(pipe_fd[<span class="number">0</span>]); <span class="comment">//关闭父进程管道读端</span></span><br><span class="line">        fd_redirect(pipe_fd[<span class="number">1</span>],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"-ef"</span>,<span class="literal">NULL</span>)&lt;<span class="number">0</span>)&#123; <span class="comment">//执行“ps -ef”命令</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"father：exec create error\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="comment">//子进程</span></span><br><span class="line">        close(pipe_fd[<span class="number">1</span>]); <span class="comment">//关闭子进程管道写端</span></span><br><span class="line">        fd_redirect(pipe_fd[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//创建一个文件用于接受输出</span></span><br><span class="line">        <span class="keyword">int</span> fd = open(<span class="string">"/tmp/tmp.txt"</span>,O_CREAT|O_WRONLY|O_APPEND,<span class="number">0600</span>);</span><br><span class="line">        fd_redirect(fd,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(execlp(<span class="string">"wc"</span>,<span class="string">"wc"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>)&lt;<span class="number">0</span>)&#123; <span class="comment">//执行“wc -l”命令</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"son：exec create error\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fd_redirect</span><span class="params">(<span class="keyword">int</span> oldfd,<span class="keyword">int</span> newfd)</span></span>&#123;</span><br><span class="line">    close(newfd); <span class="comment">//关掉原来的文件，因为下面会给它复制一个新的</span></span><br><span class="line">    <span class="keyword">if</span>(dup2(oldfd,newfd)&lt;<span class="number">0</span>)&#123;  <span class="comment">//把oldfd重定向到newfd, newfd，oldfd指向同一个文件表</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dup1 create error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/11/Linux编程——无名管道/14802069-3ae52f98966c2bd5.webp" alt><br>管道的总体原理就是（ps -ef | wc -l）</p><p>1）A/B两个进程，B进程是A的子进程，A进程执行ps -ef，B进程执行wc -l</p><p>2）将A进程的标准输出通过dup2命令重定向到一个buffer区</p><p>3）B进程的标准输入通过dup2重定向到同一个buffer区</p><p>4）B进程获取到A进程的输出并执行自己的逻辑</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编程目标&quot;&gt;&lt;a href=&quot;#编程目标&quot; class=&quot;headerlink&quot; title=&quot;编程目标&quot;&gt;&lt;/a&gt;编程目标&lt;/h3&gt;&lt;p&gt;利用编程模拟shell中的管道操作“ps -ef | wc -l”&lt;/p&gt;
&lt;h3 id=&quot;重要函数&quot;&gt;&lt;a href=&quot;#重要函数&quot; class=&quot;headerlink&quot; title=&quot;重要函数&quot;&gt;&lt;/a&gt;重要函数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;int pipe(int pipe_fd[2]); //管道函数&lt;/li&gt;
&lt;li&gt;int dup2(int oldfd, int newfd);&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="c语言" scheme="http://yoursite.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Android绑定服务</title>
    <link href="http://yoursite.com/2020/04/23/Android%E7%BB%91%E5%AE%9A%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/04/23/Android绑定服务/</id>
    <published>2020-04-23T09:46:13.000Z</published>
    <updated>2020-04-23T10:45:00.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>你可以创建同时具有已启动和已绑定两种状态的服务。换言之，可通过调用 startService() 启动服务，让服务无限期运行；此外，还可通过调用 bindService() 让客户端绑定到该服务。<br><a id="more"></a><br>如果您确实允许服务同时具有已启动和已绑定状态，则在启动服务后，如果所有客户端均解绑服务，则系统不会销毁该服务。为此，您必须通过调用 stopSelf() 或 stopService() 显式停止服务。</p><p>尽管您通常应实现 onBind() 或 onStartCommand()，但有时需同时实现这两种方法。例如，音乐播放器可能认为，让其服务无限期运行并同时提供绑定会很有用处。如此一来，Activity 便可通过启动服务来播放音乐，并且即使用户离开应用，音乐也不会停止。然后，当用户返回应用时，Activity 便能绑定到服务，重新获得回放控制权。</p><p>客户端通过调用 bindService() 绑定到服务。调用时，它必须提供 ServiceConnection 的实现，后者会监控与服务的连接。bindService() 的返回值表明所请求的服务是否存在，以及是否允许客户端访问该服务。当创建客户端与服务之间的连接时，Android 系统会调用 ServiceConnection 上的 onServiceConnected()。onServiceConnected() 方法包含 IBinder 参数，客户端随后会使用该参数与绑定服务进行通信。</p><p>您可以同时将多个客户端连接到服务。但是，系统会缓存 IBinder 服务通信通道。换言之，只有在第一个客户端绑定服务时，系统才会调用服务的 onBind() 方法来生成 IBinder。然后，系统会将同一 IBinder 传递至绑定到相同服务的所有其他客户端，无需再次调用 onBind()。</p><p>当最后一个客户端取消与服务的绑定时，系统会销毁服务（除非 startService() 也启动了该服务）。</p><p>绑定过程分为两部分，服务端创建绑定服务并返回IBinder对象，客户端利用IBinder对象绑定服务</p><h3 id="创建绑定服务"><a href="#创建绑定服务" class="headerlink" title="创建绑定服务"></a>创建绑定服务</h3><p>服务端提供接口返回IBinder对象，您可以通过三种方法定义接口：</p><h5 id="扩展Binder类"><a href="#扩展Binder类" class="headerlink" title="扩展Binder类"></a>扩展Binder类</h5><p>  适合本地绑定，客户端与服务端在同一进程，不可用于跨进程的绑定。</p><h5 id="使用Messager"><a href="#使用Messager" class="headerlink" title="使用Messager"></a>使用Messager</h5><p>  如需让接口跨不同进程工作，您可以使用 Messenger 为服务创建接口。这是执行进程间通信 (IPC) 最为简单的方法，因为 Messenger 会在单个线程中创建包含所有请求的队列，这样您就不必对服务进行线程安全设计。</p><h5 id="使用AIDL"><a href="#使用AIDL" class="headerlink" title="使用AIDL"></a>使用AIDL</h5><p>  Android 接口定义语言 (AIDL) 会将对象分解成原语，操作系统可通过识别这些原语并将其编组到各进程中来执行 IPC。对于之前采用 Messenger 的方法而言，其实际上是以 AIDL 作为其底层结构。它可以让服务同时处理多个请求，但 您的服务必须达到线程安全的要求，并且能够进行多线程处理。<br>  如要直接使用 AIDL，您必须创建定义编程接口的 .aidl 文件。Android SDK 工具会利用该文件生成实现接口和处理 IPC 的抽象类，您随后可在服务内对该类进行扩展。<br>    注：不推荐使用。  </p><h3 id="扩展Binder类实现"><a href="#扩展Binder类实现" class="headerlink" title="扩展Binder类实现"></a>扩展Binder类实现</h3><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>  1.创建一个类继承Binder，并重写getService()方法，来返回服务类对象。实例化该类。<br>  2.服务类重写onBind() 回调方法返回此 Binder 实例。<br>  3.在客户端中，从 onServiceConnected() 回调方法接收 Binder，并使用提供的方法调用绑定服务。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Binder given to clients</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder binder = <span class="keyword">new</span> LocalBinder();</span><br><span class="line">    <span class="comment">// Random number generator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random mGenerator = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">        <span class="function">LocalService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> LocalService.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** method for clients */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandomNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mGenerator.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Messager的实现"><a href="#使用Messager的实现" class="headerlink" title="使用Messager的实现"></a>使用Messager的实现</h3><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><p>  1.服务实现一个 Handler，由该类为每个客户端调用接收回调。<br>  2.服务使用 Handler 来创建 Messenger 对象（对 Handler 的引用）。<br>  3.Messenger 创建一个 IBinder，服务通过 onBind() 使其返回客户端。<br>  4.客户端使用 IBinder 将 Messenger（其引用服务的 Handler）实例化，然后使用后者将 Message 对象发送给服务。<br>  5.服务在其 Handler 中（具体地讲，是在 handleMessage() 方法中）接收每个 Message。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 服务端</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Command to the service to display a message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_SAY_HELLO = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Handler of incoming messages from clients.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IncomingHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Context applicationContext;</span><br><span class="line"></span><br><span class="line">        IncomingHandler(Context context) &#123;</span><br><span class="line">            applicationContext = context.getApplicationContext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_SAY_HELLO:</span><br><span class="line">                    Toast.makeText(applicationContext, <span class="string">"hello!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Target we publish for clients to send messages to IncomingHandler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Messenger mMessenger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When binding to the service, we return an interface to our messenger</span></span><br><span class="line"><span class="comment">     * for sending messages to the service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(), <span class="string">"binding"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> IncomingHandler(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 客户端  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityMessenger</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Messenger mService = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> bound;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName className, IBinder service)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            bound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName className)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            mService = <span class="keyword">null</span>;</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!bound) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// Create and send a message to the service, using a supported 'what' value</span></span><br><span class="line">        Message msg = Message.obtain(<span class="keyword">null</span>, MessengerService.MSG_SAY_HELLO, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        <span class="comment">// Bind to the service</span></span><br><span class="line">        bindService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class), mConnection,</span><br><span class="line">        Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        <span class="comment">// Unbind from the service</span></span><br><span class="line">        <span class="keyword">if</span> (bound) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            bound = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端绑定服务"><a href="#客户端绑定服务" class="headerlink" title="客户端绑定服务"></a>客户端绑定服务</h3><h5 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h5><p>1.实现 ServiceConnection。<br>您的实现必须重写两个回调方法：</p><p>onServiceConnected():  系统会调用该方法，进而传递服务的 onBind() 方法所返回的 IBinder。</p><p>onServiceDisconnected(): 当与服务的连接意外中断（例如服务崩溃或被终止）时，Android 系统会调用该方法。当客户端取消绑定时，系统不会调用该方法。</p><p>2.调用 bindService()，从而传递 ServiceConnection 实现。</p><p>注意：如果方法返回“false”，则说明您的客户端未与服务进行有效连接。但是，您的客户端仍应调用 unbindService()；否则，您的客户端将阻止服务在空闲时关闭。</p><p>3.当系统调用 onServiceConnected() 回调方法时，您可以使用接口定义的方法开始调用服务。</p><p>4.如要断开与服务的连接，请调用 unbindService()。</p><p>当应用销毁客户端时，如果该客户端仍与服务保持绑定状态，则该销毁会导致客户端取消绑定。更好的做法是在客户端与服务交互完成后，立即取消与该客户端的绑定。这样可以关闭空闲服务。</p><h5 id="重要的点"><a href="#重要的点" class="headerlink" title="重要的点"></a>重要的点</h5><ul><li>bindService()<ul><li>第一个参数是一个 Intent，用于显式命名要绑定的服务。</li><li>第二个参数是 ServiceConnection 对象。</li><li>第三个参数是指示绑定选项的标记。如要创建尚未处于活动状态的服务，此参数应为 BIND_AUTO_CREATE。其他可能的值为 BIND_DEBUG_UNBIND 和 BIND_NOT_FOREGROUND，或者 0（表示无此参数）。</li></ul></li><li>绑定时机<ul><li>如果您只需在 Activity 可见时与服务交互，则应在 onStart() 期间进行绑定，在 onStop() 期间取消绑定。</li><li>当 Activity 在后台处于停止运行状态时，若您仍希望其能接收响应，则可在 onCreate() 期间进行绑定，在 onDestroy() 期间取消绑定。请注意，这意味着您的 Activity 在整个运行过程中（甚至包括后台运行期间）均需使用服务，因此如果服务位于其他进程内，则当您提高该进程的权重时，系统便更有可能会将其终止。</li><li>不应在 Activity 的 onResume() 和 onPause() 期间绑定和取消绑定，因为每次切换生命周期状态时都会发生这些回调，并且您应让这些转换期间的处理工作保持最少。</li></ul></li></ul><h3 id="管理绑定服务的生命周期"><a href="#管理绑定服务的生命周期" class="headerlink" title="管理绑定服务的生命周期"></a>管理绑定服务的生命周期</h3><p>如果您的服务已启动并接受绑定，则当系统调用您的 onUnbind() 方法时，如果您想在客户端下一次绑定到服务时接收 onRebind() 调用，则可选择返回 true。onRebind() 返回空值，但客户端仍在其 onServiceConnected() 回调中接收 IBinder。下图说明这种生命周期的逻辑。</p><p><img src="https://developer.android.google.cn/images/fundamentals/service_binding_tree_lifecycle.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;p&gt;你可以创建同时具有已启动和已绑定两种状态的服务。换言之，可通过调用 startService() 启动服务，让服务无限期运行；此外，还可通过调用 bindService() 让客户端绑定到该服务。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>i++与++i的实现</title>
    <link href="http://yoursite.com/2020/04/04/i-%E4%B8%8E-i%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/04/04/i-与-i的实现/</id>
    <published>2020-04-04T08:45:06.000Z</published>
    <updated>2020-04-04T08:54:34.378Z</updated>
    
    <content type="html"><![CDATA[<p>i++与++i都是从右向左结合的，i++有滞后性，会先赋值再加一，而++i会先加一再赋值。<br><a id="more"></a></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li><p>i++的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">int</span>::<span class="keyword">operator</span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> oldValue = *<span class="keyword">this</span>;</span><br><span class="line">      ++(*<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;<span class="comment">// 因为返回的是拷贝的临时变量，所以不能是左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>++i的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">int</span>::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">   *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>感觉看完后，有了更深刻的印象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;i++与++i都是从右向左结合的，i++有滞后性，会先赋值再加一，而++i会先加一再赋值。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言运算符优先级</title>
    <link href="http://yoursite.com/2020/04/04/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/04/04/C语言运算符优先级/</id>
    <published>2020-04-04T08:19:37.000Z</published>
    <updated>2020-04-04T08:37:54.353Z</updated>
    
    <content type="html"><![CDATA[<p>…………………….<br><a id="more"></a></p><table border="1" cellspacing="0" cellpadding="0" width="612"><tbody><tr><td><p align="center"><strong>优先级</strong></p></td><td><p align="center"><strong>运算符</strong></p></td><td><p align="center"><strong>名称或含义</strong></p></td><td><p align="center"><strong>使用形式</strong></p></td><td><p align="center"><strong>结合方向</strong></p></td><td><p align="center"><strong>说明</strong></p></td></tr><tr><td rowspan="4"><p align="center"><strong>1</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">[]</span></strong></p></td><td><p>数组下标</p></td><td><p>数组名[常量表达式]</p></td><td rowspan="4"><p align="center">左到右</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">()</span></strong></p></td><td><p>圆括号</p></td><td><p>(表达式）/函数名(形参表)</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">.</span></strong></p></td><td><p>成员选择（对象）</p></td><td><p>对象.成员名</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">-&gt;</span></strong></p></td><td><p>成员选择（指针）</p></td><td><p>对象指针-&gt;成员名</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="9"><p align="center"><strong>2</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">-</span></strong></p></td><td><p>负号运算符</p></td><td><p>-表达式</p></td><td rowspan="9"><p align="center"><strong><span style="COLOR: red">右到左</span></strong></p></td><td rowspan="7"><p align="center">单目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">~</span></strong></p></td><td><p>按位取反运算符</p></td><td><p>~表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">++</span></strong></p></td><td><p>自增运算符</p></td><td><p>++变量名/变量名++</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">--</span></strong></p></td><td><p>自减运算符</p></td><td><p>--变量名/变量名--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">*</span></strong></p></td><td><p>取值运算符</p></td><td><p>*指针变量</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&amp;</span></strong></p></td><td><p>取地址运算符</p></td><td><p>&amp;变量名</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">!</span></strong></p></td><td><p>逻辑非运算符</p></td><td><p>!表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">(</span><span style="COLOR: blue">类型</span><span style="COLOR: blue">)</span></strong></p></td><td><p>强制类型转换</p></td><td><p>(数据类型)表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">sizeof</span></strong></p></td><td><p>长度运算符</p></td><td><p>sizeof(表达式)</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="3"><p align="center"><strong>3</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">/</span></strong></p></td><td><p>除</p></td><td><p>表达式/表达式</p></td><td rowspan="3"><p align="center">左到右</p></td><td rowspan="3"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">*</span></strong></p></td><td><p>乘</p></td><td><p>表达式*表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">%</span></strong></p></td><td><p>余数（取模）</p></td><td><p>整型表达式%整型表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>4</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">+</span></strong></p></td><td><p>加</p></td><td><p>表达式+表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">-</span></strong></p></td><td><p>减</p></td><td><p>表达式-表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>5</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&lt;&lt;&nbsp;</span></strong></p></td><td><p>左移</p></td><td><p>变量&lt;&lt;表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&gt;&gt;&nbsp; </span></strong></p></td><td><p>右移</p></td><td><p>变量&gt;&gt;表达式</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="4"><p align="center"><strong>6</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&gt;&nbsp;</span></strong></p></td><td><p>大于</p></td><td><p>表达式&gt;表达式</p></td><td rowspan="4"><p align="center">左到右</p></td><td rowspan="4"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&gt;=</span></strong></p></td><td><p>大于等于</p></td><td><p>表达式&gt;=表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&lt;&nbsp;</span></strong></p></td><td><p>小于</p></td><td><p>表达式&lt;表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&lt;=</span></strong></p></td><td><p>小于等于</p></td><td><p>表达式&lt;=表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>7</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">==</span></strong></p></td><td><p>等于</p></td><td><p>表达式==表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">！</span><span style="COLOR: blue">=</span></strong></p></td><td><p>不等于</p></td><td><p>表达式!= 表达式</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>8</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&amp;</span></strong></p></td><td><p>按位与</p></td><td><p>表达式&amp;表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>9</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">^</span></strong></p></td><td><p>按位异或</p></td><td><p>表达式^表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>10</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">|</span></strong></p></td><td><p>按位或</p></td><td><p>表达式|表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>11</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&amp;&amp;</span></strong></p></td><td><p>逻辑与</p></td><td><p>表达式&amp;&amp;表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>12</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">||</span></strong></p></td><td><p>逻辑或</p></td><td><p>表达式||表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>13</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">?:</span></strong></p></td><td><p>条件运算符</p></td><td><p>表达式1? </p><p>表达式2: 表达式3</p></td><td><p align="center"><strong><span style="COLOR: red">右到左</span></strong></p></td><td><p align="center"><span style="COLOR: red">三目运算符</span></p></td></tr><tr><td width="612" colspan="6"><p><span style="COLOR: red"></span>&nbsp;</p></td></tr><tr><td rowspan="11"><p align="center"><strong>14</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">=</span></strong></p></td><td><p>赋值运算符</p></td><td><p>变量=表达式</p></td><td rowspan="11"><p align="center"><strong><span style="COLOR: red">右到左</span></strong></p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">/=</span></strong></p></td><td><p>除后赋值</p></td><td><p>变量/=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">*=</span></strong></p></td><td><p>乘后赋值</p></td><td><p>变量*=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">%=</span></strong></p></td><td><p>取模后赋值</p></td><td><p>变量%=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">+=</span></strong></p></td><td><p>加后赋值</p></td><td><p>变量+=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">-=</span></strong></p></td><td><p>减后赋值</p></td><td><p>变量-=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&lt;&lt;=</span></strong></p></td><td><p>左移后赋值</p></td><td><p>变量&lt;&lt;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&gt;&gt;=</span></strong></p></td><td><p>右移后赋值</p></td><td><p>变量&gt;&gt;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&amp;=</span></strong></p></td><td><p>按位与后赋值</p></td><td><p>变量&amp;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">^=</span></strong></p></td><td><p>按位异或后赋值</p></td><td><p>变量^=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">|=</span></strong></p></td><td><p>按位或后赋值</p></td><td><p>变量|=表达式</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>15</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">，</span></strong></p></td><td><p>逗号运算符</p></td><td><p>表达式,表达式,…</p></td><td><p align="center">左到右</p></td><td><p align="center">--</p></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;…………………….&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>VSCode编写Vue的基础配置</title>
    <link href="http://yoursite.com/2020/04/04/VSCode%E7%BC%96%E5%86%99Vue%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/04/VSCode编写Vue的基础配置/</id>
    <published>2020-04-04T04:31:01.000Z</published>
    <updated>2020-04-23T10:50:15.527Z</updated>
    
    <content type="html"><![CDATA[<h5 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h5><ul><li>Vetur</li><li>ESLint</li><li>Prettier for VSCode</li><li>Auto Close Tag</li><li>Auto Rename Tag</li><li>Path Intellisense<a id="more"></a><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5>在工程下，创建.prettierrc文件，并添入<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"semi": false,//避免自动生成分号</span><br><span class="line">"singleQuote": true,//双引号变为单引号</span><br><span class="line">"editor.formatOnSave": true,</span><br><span class="line">"editor.defaultFormatter": "SimonSiefke.prettier-vscode",</span><br><span class="line">"trailingComma": "none"//避免自动生成逗号</span><br></pre></td></tr></table></figure></li></ul><p>在.eslintrc.js文件中的，rule项中，添入<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'prettier/prettier': 'off',</span><br><span class="line">'space-before-function-paren':0//避免因空格引起的错误</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Vetur&lt;/li&gt;
&lt;li&gt;ESLint&lt;/li&gt;
&lt;li&gt;Prettier for VSCode&lt;/li&gt;
&lt;li&gt;Auto Close Tag&lt;/li&gt;
&lt;li&gt;Auto Rename Tag&lt;/li&gt;
&lt;li&gt;Path Intellisense&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="VSCode" scheme="http://yoursite.com/tags/VSCode/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>RSA加密原理</title>
    <link href="http://yoursite.com/2020/03/25/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/25/RSA加密原理/</id>
    <published>2020-03-25T03:00:23.000Z</published>
    <updated>2020-04-23T10:48:44.469Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RSA简单介绍"><a href="#RSA简单介绍" class="headerlink" title="RSA简单介绍"></a>RSA简单介绍</h4><p>RSA是 一种非对称加密算法，号称地球上最安全的加密算法，它建立的基础利用了大数素分解的困难性。<br><a id="more"></a></p><h4 id="RSA的组成"><a href="#RSA的组成" class="headerlink" title="RSA的组成"></a>RSA的组成</h4><ul><li>两个素数p，q</li><li>公钥$=（e,n）$</li><li>私钥$=（d,n）$</li><li>加密公式：$ 密文=明文^e mod n$</li><li>解密公式：$明文=密文^dmodn$<h4 id="需要先了解的知识"><a href="#需要先了解的知识" class="headerlink" title="需要先了解的知识"></a>需要先了解的知识</h4></li><li>$\varphi(n)$是欧拉函数，表示小于或等于n的正整数中与n互质的数的数目</li><li>当n是质数时，$\varphi(n)=n-1$</li><li>$\varphi(p<em>q)=\varphi(p) </em> \varphi(q)$</li><li>gcd(a,b)，计算a，b的最大公约数    </li><li><p>欧几里得算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展欧几里得算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exGcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exGcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;x=y;y=t-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="RSA过程"><a href="#RSA过程" class="headerlink" title="RSA过程"></a>RSA过程</h4><ol><li>生成两个素数 p，q</li><li>$n = p*q $</li><li>$\varphi(n)=(p-1)(q-1)$</li><li>生成e，要求  <ul><li>$1&lt;e&lt;\varphi(n)$</li><li>$gcd(\varphi(n),e)=1,即\varphi(n)与e互质$</li></ul></li><li>生成d，要求$ed=1 mod \varphi(n)$</li><li>最终把 $(e,n)$ 封装成公钥， $(d,n)$ 封装成私钥。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;RSA简单介绍&quot;&gt;&lt;a href=&quot;#RSA简单介绍&quot; class=&quot;headerlink&quot; title=&quot;RSA简单介绍&quot;&gt;&lt;/a&gt;RSA简单介绍&lt;/h4&gt;&lt;p&gt;RSA是 一种非对称加密算法，号称地球上最安全的加密算法，它建立的基础利用了大数素分解的困难性。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="RSA" scheme="http://yoursite.com/tags/RSA/"/>
    
  </entry>
  
  <entry>
    <title>android的Handler机制</title>
    <link href="http://yoursite.com/2020/03/24/android%E7%9A%84Handler%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/03/24/android的Handler机制/</id>
    <published>2020-03-24T10:36:00.000Z</published>
    <updated>2020-03-24T11:52:03.021Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Handler是什么？"><a href="#Handler是什么？" class="headerlink" title="Handler是什么？"></a>Handler是什么？</h4><p>在Android中，Handler被用来提供用于线程间通信，以确保线程通信安全（比如UI线程的安全）。包含四个组成部分：Message，Looper，MessageQueue，Handler，这四个组成部分构成了多线程中经典的“生产者————消费者模型”<br><a id="more"></a></p><ol><li>成员介绍 </li></ol><ul><li>Message：主要功能是进行消息的封装，同时可以指定消息的操作形式； </li><li>Looper：消息循环泵，用来为一个线程跑一个消息循环。每一个线程最多只可以拥有一个。 </li><li>MessageQueue：就是一个消息队列，存放消息的地方。每一个线程最多只可以拥有一个。 </li><li>Handler：消息的处理者，handler 负责将需要传递的信息封装成Message，发送给Looper，继而由Looper将Message放入MessageQueue中。当Looper对象看到MessageQueue中含有Message，就将其广播出去。该handler 对象收到该消息后，调用相应的handler 对象的handleMessage()方法对其进行处理。 </li></ul><ol><li>同线程各成员的关系及数量 </li></ol><ul><li>一个线程中只能有一个Looper，只能有一个MessageQueue，可以有多个Handler，多个Messge； </li><li>一个Looper只能维护唯一一个MessageQueue，可以接受多个Handler发来的消息； </li><li>一个Message只能属于唯一一个Handler； </li><li>同一个Handler只能处理自己发送给Looper的那些Message；<h4 id="为什么需要Handler？"><a href="#为什么需要Handler？" class="headerlink" title="为什么需要Handler？"></a>为什么需要Handler？</h4>最主要的原因是，在android中遵循单线程模型，子线程不允许访问UI，只有主线程才能访问UI。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable() &#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        myView.invalidate();    </span><br><span class="line">    &#125;            </span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ul><p>这样的代码在android中是不被允许的。</p><p>所以，当子线程想要更新UI时，就需要调用主线程中的Handler对象，通过Handler向主线程传递消息来通知更新UI。需要注意的是当Handler被创建时，它就与创建它的线程绑定，且定义Handler都用静态内部类的方式。</p><h4 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h4><ul><li><p>sendMessage(Message)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> currentPos  = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> duration = <span class="number">2</span>;</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putInt(<span class="string">"currentPos"</span>,currentPos);</span><br><span class="line">bundle.putInt(<span class="string">"duration"</span>,duration);</span><br><span class="line">Message msg  =  Message.obtain();</span><br><span class="line">msg.what = <span class="number">1</span>;<span class="comment">//标志消息的标志</span></span><br><span class="line">msg.setData(bundle);</span><br><span class="line">MainActivity.handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></li><li><p>post(Runnable)<br>post与sendMessage本质上很相似，首先，他们都可以传递信息，其次，通过阅读源码可以看出post就是把Runnable对象打包进了一个Message，然后使用sendMessageDelayed方法发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        更新UI</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>handleMessage(Message)<br>处理Message，当Looper收到Message时，会自动调用它。</p><h4 id="Handler-通信机制"><a href="#Handler-通信机制" class="headerlink" title="Handler 通信机制"></a>Handler 通信机制</h4></li></ul><p><img src="https://i.bmp.ovh/imgs/2020/03/bf967fb7ee375441.png" alt></p><ul><li>创建Handler，并采用当前线程的Looper创建消息循环系统；</li><li>Handler通过sendMessage(Message)或Post(Runnable)发送消息，调用enqueueMessage把消息插入到消息链表中；</li><li>Looper循环检测消息队列中的消息，若有消息则取出该消息，并调用该消息持有的handler的dispatchMessage方法，回调到创建Handler线程中重写的handleMessage里执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Handler是什么？&quot;&gt;&lt;a href=&quot;#Handler是什么？&quot; class=&quot;headerlink&quot; title=&quot;Handler是什么？&quot;&gt;&lt;/a&gt;Handler是什么？&lt;/h4&gt;&lt;p&gt;在Android中，Handler被用来提供用于线程间通信，以确保线程通信安全（比如UI线程的安全）。包含四个组成部分：Message，Looper，MessageQueue，Handler，这四个组成部分构成了多线程中经典的“生产者————消费者模型”&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="http://yoursite.com/2020/03/24/cookie%E5%92%8Csession/"/>
    <id>http://yoursite.com/2020/03/24/cookie和session/</id>
    <published>2020-03-24T02:43:44.000Z</published>
    <updated>2020-03-24T02:49:28.743Z</updated>
    
    <content type="html"><![CDATA[<p>………..<br><a id="more"></a></p><h5 id="一、cookie："><a href="#一、cookie：" class="headerlink" title="一、cookie："></a>一、cookie：</h5><p>在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。</p><h5 id="二、session"><a href="#二、session" class="headerlink" title="二、session:"></a>二、session:</h5><p>session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。</p><h5 id="三、cookie和session结合使用："><a href="#三、cookie和session结合使用：" class="headerlink" title="三、cookie和session结合使用："></a>三、cookie和session结合使用：</h5><p>web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：</p><ol><li>存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。</li></ol><ol><li>将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;………..&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="http://yoursite.com/2020/03/23/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/03/23/IDEA快捷键/</id>
    <published>2020-03-23T13:06:10.000Z</published>
    <updated>2020-03-24T02:47:35.396Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ctrl+p: 查看函数参数情况</li><li>双击shift：搜索框</li><li>shift+回车：不管光标在哪，都会开始下一行</li><li>ctrl+shift+f12: 代码编辑框，最大化和还原</li><li>alt+ins：generate，可以产生geter，seter方法</li><li>ctrl+shift+v</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;ctrl+p: 查看函数参数情况&lt;/li&gt;
&lt;li&gt;双击shift：搜索框&lt;/li&gt;
&lt;li&gt;shift+回车：不管光标在哪，都会开始下一行&lt;/li&gt;
&lt;li&gt;ctrl+shift+f12: 代码编辑框，最大化和还原&lt;/li&gt;
&lt;li&gt;alt+ins：gener
      
    
    </summary>
    
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>git的简单使用</title>
    <link href="http://yoursite.com/2020/03/23/git%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/03/23/git的简单使用/</id>
    <published>2020-03-23T09:16:22.000Z</published>
    <updated>2020-04-03T10:38:52.592Z</updated>
    
    <content type="html"><![CDATA[<p>………..<br><a id="more"></a></p><h6 id="这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客"><a href="#这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客" class="headerlink" title="这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客"></a>这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客</h6><h4 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h4><p>这步很简单，不过多介绍，这是新建后的仓库的样子<br><img src="https://i.bmp.ovh/imgs/2020/03/48b87afcfa5ca51a.png" alt><br>这里给出了三种情况，第一种是你没有一个仓库；第二种是你已经有了一个本地的仓库；第三种是你要从其他仓库导入。<br>下面给出 了git的一些命令，我们完全可以把它copy过来在git的命令行里运行，但是在这之前如果没有ssh密钥的，需要新建一个。 </p><h4 id="新建SSH密钥"><a href="#新建SSH密钥" class="headerlink" title="新建SSH密钥"></a>新建SSH密钥</h4><p>点击setting，在里面找到Deploy keys，进入。<br><img src="https://i.bmp.ovh/imgs/2020/03/21a10ce1db4c346b.png" alt><br>因为，我们是 第一次使用，所以我需要在我本地，新建一个SSH密钥（新建一次即可，下次只需把这个密钥加到github）。点击“guide on deploy keys ”的 超链接跟随它的英文教程，一步步进行即可。<br>这是我对它教程的一个总结：</p><h6 id="创建一个新的SSH-key："><a href="#创建一个新的SSH-key：" class="headerlink" title="创建一个新的SSH key："></a>创建一个新的SSH key：</h6><ol><li>打开git bash</li><li>把下面的换成你的邮箱<br><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code> </li><li>下面会弹出对话，问你把密钥存在那个地方，一般直接回车存在C盘下面<br><code>Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):</code></li><li>下面会让你输入两次密码： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure></li></ol><h6 id="将SSH密钥添加到SSH-agent："><a href="#将SSH密钥添加到SSH-agent：" class="headerlink" title="将SSH密钥添加到SSH-agent："></a>将SSH密钥添加到SSH-agent：</h6><ol><li>打开ssh-agent<br><code>eval `ssh-agent` </code></li><li>加入<br><code>ssh-add ~/.ssh/id_rsa</code><h6 id="将ssh-key添加到github："><a href="#将ssh-key添加到github：" class="headerlink" title="将ssh-key添加到github："></a>将ssh-key添加到github：</h6></li><li>复制你的公钥<br><code>clip &lt; ~/.ssh/id_rsa.pub</code><br>也可以去存储密钥的文件直接复制id_rsa.pub里的内容</li><li>去到这个界面，点击“Add deploy key”<br><img src="https://i.bmp.ovh/imgs/2020/03/21a10ce1db4c346b.png" alt></li><li>填写tital，粘贴公钥，最后勾选“Allow write access”<br><img src="https://i.bmp.ovh/imgs/2020/03/8c7250f09bb4025f.png" alt></li></ol><h4 id="上传项目到github"><a href="#上传项目到github" class="headerlink" title="上传项目到github"></a>上传项目到github</h4><ol><li>到你想要上传项目的文件夹下<br><code>git init</code></li><li>可以为你的项目添加一个README<br><code>git add README.md</code></li><li>把上传到文件添加到缓存<br><code>git add .</code></li><li>查看git的状态<br><code>git status</code></li><li>提交,-m表示这次提交的备注<br><code>git commit -m &quot;first commit&quot;</code></li><li>添加远程主机<br><code>git remote add origin https://github.com/iotZHY/demo.git</code></li><li>push<br><code>git push -u origin master</code><h4 id="git命令的进阶学习（持续更新-）"><a href="#git命令的进阶学习（持续更新-）" class="headerlink" title="git命令的进阶学习（持续更新 ）"></a>git命令的进阶学习（持续更新 ）</h4></li></ol><ul><li>git commit —amend，也叫追加提交<br>情景：如果我们不小心提交了一版我们不满意的代码，并且给它推送到服务器了，在代码没被merge之前我们希望再修改一版满意的，而如果我们不想在服务器上abondon，它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中。</li><li>git pull:从远端拉取仓库，用于多人协作开发同步</li><li>git checkout -b 分支名:新建 一个分支，并切换到该分支</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;………..&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>VPN与NAT</title>
    <link href="http://yoursite.com/2020/03/22/VPN%E4%B8%8ENAT/"/>
    <id>http://yoursite.com/2020/03/22/VPN与NAT/</id>
    <published>2020-03-22T02:33:40.000Z</published>
    <updated>2020-03-23T00:14:42.784Z</updated>
    
    <content type="html"><![CDATA[<h4 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h4><p>  由于ip地址的短缺，一个机构内可以申请到的ip地址数远远小于机构内的主机数，且也考虑到互联网的安全性，也不会把所有的主机接入互联网。为了解决问题 RFC1918指明了一些专用地址 ，这些地址只能用于一个机构内通讯 ，而不能用于互联网上的通讯。互联网上的路由器 对目的地址时专用地址的数据报一律不转发。专用地址是全球不唯一的，可重复的，自然也就无法连入互联网。一共有三个地址块：<br>（1）10.0.0.0——10.255.255.255<br>（2）172.16.0.0——172.31.255.255<br>（3）192.168.0.0——192.168.255.255<br><a id="more"></a></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>如果这些机构内的主机想要和互联网上的主机通信时该咋办呢？<br>如何连接两个异地的局域网？</p><h4 id="NAT技术："><a href="#NAT技术：" class="headerlink" title="NAT技术："></a>NAT技术：</h4><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。<br>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p><ul><li>静态转换：IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。</li><li>动态转换：ip地址是多对多的，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</li><li>端口多路复用（PAT)是指改变外出数据包的源端口并进行端口转换，即端口地址转换。ip地址一对多，内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</li></ul><p>NAT工作流程：<br><img src="https://bkimg.cdn.bcebos.com/pic/0dd7912397dda144810a190cb2b7d0a20cf48608?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U3Mg==,xp_5,yp_5" alt></p><ul><li>第一步，局域网主机发出IP数据报（RES=192.168.1.100，DES=202.113.112.x），经过NAT网关时，NAT网关会根据它的映射表，修改数据报的源地址为一个合法的公网地址，这时的数据报变为（RES=202.113.113.x，DES=202.113.112.x），发送给服务器</li><li>第二部分，服务器收到后，以为给他发送消息的主机的ip为202.113.113.x，于是把请求到的数据发送给202.113.113.x，故发出的ip报文（RES=202.113.112.x，DES=202.113.113.x），经过NAT网关时，它把ip报文的目的地址根据映射表改为局域网内的ip，ip报文变为（RES=202.113.112.x，DES=192.168.1.100）</li></ul><h4 id="VPN技术："><a href="#VPN技术：" class="headerlink" title="VPN技术："></a>VPN技术：</h4><p>虚拟专用网络(VPN)的功能是：在公用网络上建立专用网络，进行加密通讯。通常情况下，VPN网关采取双网卡结构，外网卡使用公网IP接入Internet。 同一组网中，各个网络的网段不能相同。</p><p>VPN工作流程：<br><img src="https://i.bmp.ovh/imgs/2020/03/65d04d3db84455b9.png" alt></p><ol><li>网络一的VPN网关在接收到终端X发出的访问数据包时对其目标地址进行检查，如果目标地址属于网络二的地址，则将该数据包进行封装，封装的方式根据所采用的VPN技术不同而不同，同时VPN网关会构造一个新VPN数据包，并将封装后的原数据包作为VPN数据包的负载，VPN数据包的目标地址为网络二的VPN网关的外部地址。 </li><li>网络一的VPN网关将VPN数据包发送到Internet，由于VPN数据包的目标地址是网络二的VPN网关的外部地址，所以该数据包将被Internet中的路由正确地发送到网络二的VPN网关。 </li><li>网络二的VPN网关对接收到的数据包进行检查，如果发现该数据包是从网络一的VPN网关发出的，即可判定该数据包为VPN数据包，并对该数据包进行解包处理。解包的过程主要是先将VPN数据包的包头剥离，再将数据包反向处理还原成原始的数据包。 </li><li>网络二的VPN网关将还原后的原始数据包发送至目标终端B，由于原始数据包的目标地址是终端B的IP，所以该数据包能够被正确地发送到终端B。在终端B看来，它收到的数据包就和从终端A直接发过来的一样。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;产生的原因：&quot;&gt;&lt;a href=&quot;#产生的原因：&quot; class=&quot;headerlink&quot; title=&quot;产生的原因：&quot;&gt;&lt;/a&gt;产生的原因：&lt;/h4&gt;&lt;p&gt;  由于ip地址的短缺，一个机构内可以申请到的ip地址数远远小于机构内的主机数，且也考虑到互联网的安全性，也不会把所有的主机接入互联网。为了解决问题 RFC1918指明了一些专用地址 ，这些地址只能用于一个机构内通讯 ，而不能用于互联网上的通讯。互联网上的路由器 对目的地址时专用地址的数据报一律不转发。专用地址是全球不唯一的，可重复的，自然也就无法连入互联网。一共有三个地址块：&lt;br&gt;（1）10.0.0.0——10.255.255.255&lt;br&gt;（2）172.16.0.0——172.31.255.255&lt;br&gt;（3）192.168.0.0——192.168.255.255&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>本地用户文件名的修改</title>
    <link href="http://yoursite.com/2020/02/21/%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2020/02/21/本地用户文件名的修改/</id>
    <published>2020-02-21T11:38:10.000Z</published>
    <updated>2020-02-21T11:59:51.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>本地用户名是我们出装系统时设置的，如果当初我们设置用户名是中文时，可能会遇到一下麻烦，对于一些不支持中文路径的软件，可能就安装不了，所以我最好再初装系统时，还是设置成英文字母为好。<a id="more"></a><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3></li><li>修改我们的注册表<ul><li>按win+r，输入regedit</li><li>按如下路径逐步点击<br><img src="https://i.bmp.ovh/imgs/2020/02/736d9cc8a0b8b5aa.png" alt></li><li>双击涂黄的文件，修改成你想改变的英文名字<br><img src="https://i.bmp.ovh/imgs/2020/02/b5bfe424ad21e2ed.png" alt></li></ul></li><li>重启<ul><li>重启后你会进入一个初始的桌面，不要慌张你的信息没有丢失。</li><li>进入c:\user目录下，修改用你以前的用户名命名的文件夹为你的新名字</li><li>重启电脑</li></ul></li><li>修改环境变量<ul><li>把环境变量中你之前用户名，改成现在的即可</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本地用户名是我们出装系统时设置的，如果当初我们设置用户名是中文时，可能会遇到一下麻烦，对于一些不支持中文路径的软件，可能就安装不了，所以我最好再初装系统时，还是设置成英文字母为好。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="win10" scheme="http://yoursite.com/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>交换机与ARP</title>
    <link href="http://yoursite.com/2020/02/19/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8EARP/"/>
    <id>http://yoursite.com/2020/02/19/交换机与ARP/</id>
    <published>2020-02-19T10:23:28.000Z</published>
    <updated>2020-02-21T12:03:29.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是交换机？"><a href="#什么是交换机？" class="headerlink" title="什么是交换机？"></a>什么是交换机？</h3><ul><li>交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机，它是以太网的核心，它工作在数据链路层，是基于MAC地址从端口到端口通信的，它不能识别IP地址，因此也叫二层交换机。<a id="more"></a><h3 id="它跟集线器的区别？"><a href="#它跟集线器的区别？" class="headerlink" title="它跟集线器的区别？"></a>它跟集线器的区别？</h3></li><li>最大的区别就在于，集线器工作在OSI模型的第一层，而交换机工作在二层。集线器就像它的名字那样，只起到了聚集的作用，它可以扩大网络，但它也加剧了信道内的碰撞，因为它的工作内容仅仅是把从这一端口收到信息广播到其他端口。而交换机它不光扩大了网络范围，也由于它使用的是单播的方式，所以它消除了碰撞，加快了网络速度。<h3 id="交换机怎样实现单播？"><a href="#交换机怎样实现单播？" class="headerlink" title="交换机怎样实现单播？"></a>交换机怎样实现单播？</h3></li><li>这得意与，它的MAC地址表，这个地址表记录交换机端口与MAC地址的映射关系（每一个端口对应一个计算机）。这个MAC地址表不是人为给交换机的，而是由交换机自己学习的。</li><li>学习过程也比较简单，就是在某一端口发送帧时，交换机会从该帧中获得源MAC，然后去自己的MAC地址表检索该端口，如果没有就直接添加，如果有则直接覆盖掉。交换机也会以固定的时间为周期来刷新MAC地址表。<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3></li><li><p>中文名称，地址解析协议，功能比较简单，就是把IP地址转换成MAC地址。它主要来维护本地主机的一个路由表。<br>让我们来简单模拟一下这个过程，A主机想要把信息发给局域网内的B主机，而A只知道B的IP而不知道B的MAC（局域网内只认识MAC），所以我们需要把IP转换成MAC，这是就用到了ARP。</p></li><li><p>这张图很能说明整个过程，只是A到B是广播，B到A是单播</p></li></ul><p><img src="https://ftp.bmp.ovh/imgs/2020/02/26d3c5b736e77011.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是交换机？&quot;&gt;&lt;a href=&quot;#什么是交换机？&quot; class=&quot;headerlink&quot; title=&quot;什么是交换机？&quot;&gt;&lt;/a&gt;什么是交换机？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机，它是以太网的核心，它工作在数据链路层，是基于MAC地址从端口到端口通信的，它不能识别IP地址，因此也叫二层交换机。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MES开发记录--环境配置</title>
    <link href="http://yoursite.com/2019/11/24/MES%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95--%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/11/24/MES开发记录--环境配置/</id>
    <published>2019-11-24T06:04:59.000Z</published>
    <updated>2019-11-26T16:46:47.936Z</updated>
    
    <content type="html"><![CDATA[<h5 id="开发所需："><a href="#开发所需：" class="headerlink" title="开发所需："></a>开发所需：</h5><ul><li>jdk （java的软件开发工具包）</li><li>Eclipse for java ee (java IDE，在里面进行主要的编码工作)</li><li>Tomcat （把自己的主机打造成服务器端）</li><li>Phpstudy （开启或关闭mysql数据库）</li><li>Navicat （对数据库可视化操作）<a id="more"></a></li></ul><hr><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li>jdk1.8<br>  官方下载地址：<br>  <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>Eclipse for java ee<br>  1.去官网找最新版本<br>  <a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a><br>  <img src="https://i.bmp.ovh/imgs/2019/11/b7615a98a49a23dd.png" alt><br>  2.下载，换个安装源会快一点，不设置这部也可以。<br>  先点击Selcet Another Mirror，再选择一个安装源。<br>  <img src="https://ftp.bmp.ovh/imgs/2019/11/79d69700c93c361f.png" alt><br>  3.下载完成后，解压即可，eclipse是不用安装的，打开文件夹会找到eclipse.exe。</li><li>Tomcat<br>  官网下载地址：(7.0版本)<br>  <a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-70.cgi</a><br>  <img src="https://i.bmp.ovh/imgs/2019/11/5c85e0647d6eb81b.png" alt><br>  tomcat是不用安装的，下载到合适的位置，解压，看到有bin、webapp等文件夹即可</li><li>Phpstudy<br>  官网下载地址：<br>  <a href="https://m.xp.cn" target="_blank" rel="noopener">https://m.xp.cn</a></li><li>Navicat<br>  官网下载地址：<br>  <a href="https://www.pcsoft.com.cn/soft/20832.html?t=1523691320938" target="_blank" rel="noopener">https://www.pcsoft.com.cn/soft/20832.html?t=1523691320938</a></li><li><p>Spring<br>  下载地址：<br>  <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/libs-release-local/org/springframework/spring/</a><br>  我下载的是4.1.9版本的，比较老，但稳定。<br>  点进去后，选择黄色标注的文件下载<br>  <img src="https://ftp.bmp.ovh/imgs/2019/11/885f4cb724a414b8.png" alt><br>  下载完，解压后，文件的结构：</p><pre><code>  docs：Spring相关文档，包括开发指南，API参考文档。  libs：该文件夹下的jar分为三类：Spring框架class文件的jar包；Spring框架源文件的压缩包，文件名以-source结尾；Spring框架API文档的压缩包，文件名以-javadoc结尾。  schemas：该文件下包含了Spring各种配置文件的XML Schema文档。  readme.txt,notice.txt,license.txt：说明性文档</code></pre><p>  另外：spring的核心容器必须依赖于common-logging的jar包<br>  网站：<br>  <a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p></li></ul><hr><h6 id="Eclipse环境配置"><a href="#Eclipse环境配置" class="headerlink" title="Eclipse环境配置"></a>Eclipse环境配置</h6><ul><li>配置tomcat server</li><li>配置jdk</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;开发所需：&quot;&gt;&lt;a href=&quot;#开发所需：&quot; class=&quot;headerlink&quot; title=&quot;开发所需：&quot;&gt;&lt;/a&gt;开发所需：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;jdk （java的软件开发工具包）&lt;/li&gt;
&lt;li&gt;Eclipse for java ee (java IDE，在里面进行主要的编码工作)&lt;/li&gt;
&lt;li&gt;Tomcat （把自己的主机打造成服务器端）&lt;/li&gt;
&lt;li&gt;Phpstudy （开启或关闭mysql数据库）&lt;/li&gt;
&lt;li&gt;Navicat （对数据库可视化操作）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JAVA高级特性 --反射</title>
    <link href="http://yoursite.com/2019/11/15/JAVA%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/11/15/JAVA高级特性-反射/</id>
    <published>2019-11-15T14:37:26.000Z</published>
    <updated>2020-04-23T10:54:16.869Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。<br>我感觉这个动态性，是大家使用反射的最重要的原因，我们可以通过反射并且根据自己的需求，动态的调用一个类的方法。</p><h4 id="怎么反射？"><a href="#怎么反射？" class="headerlink" title="怎么反射？"></a>怎么反射？</h4><p>反射最开始肯定是要先加载类，然后在剖析它的构造函数，属性，方法<br><a id="more"></a></p><h5 id="加载类的三种方法"><a href="#加载类的三种方法" class="headerlink" title="加载类的三种方法"></a>加载类的三种方法</h5><ol><li><p>使用Class类的静态方法forName()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //forName里面使用完整类的路径</span><br><span class="line">    Class clazz =Class.forName(&quot;exp.Person&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用方法getClass()，前提要新建一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = new Person().getClass();</span><br><span class="line">//在非静态方法里，也可以使用this关键字</span><br></pre></td></tr></table></figure></li><li><p>使用这个类的静态变量class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line">//这个方式简单粗暴个人很喜欢</span><br></pre></td></tr></table></figure></li></ol><h5 id="解剖类的方法"><a href="#解剖类的方法" class="headerlink" title="解剖类的方法"></a>解剖类的方法</h5><ol><li><p>public Constructor getConstructor() /构造函数<br>//参数为可变的，指定需要的构造函数的参数类型的class类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor c = class.getConstructor(String.class);</span><br><span class="line">c.newInstance();//创建一个对象</span><br></pre></td></tr></table></figure></li><li><p>public Method getMethod() //方法</p></li><li>public Field getField() //字段，成员方法，只返回public修饰的<h6 id="前面三种方式只能返回，修饰符是public的成员"><a href="#前面三种方式只能返回，修饰符是public的成员" class="headerlink" title="//前面三种方式只能返回，修饰符是public的成员"></a>//前面三种方式只能返回，修饰符是public的成员</h6></li><li>public Constructor getDeclaredConstructor() /构造函数</li><li>public Method getDeclaredMethod() //方法</li><li>public Field getDeclaredField() //字段，成员方法除public外</li></ol><ul><li>可以不用获得构造函数直接获得对象,但只限于无参的构造函数<br><code>clazz.newInstance()</code></li><li>私有的成员只能在内部被访问，但是反射可以实现访问私有成员,使用<br><code>setAccessible（true）;</code></li><li>执行方法: invoke()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = new Person().getClass();</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = clazz.getMethod(&quot;run&quot;);</span><br><span class="line">            Object obj = method.invoke(clazz.newInstance());</span><br><span class="line">            System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是反射？&quot;&gt;&lt;a href=&quot;#什么是反射？&quot; class=&quot;headerlink&quot; title=&quot;什么是反射？&quot;&gt;&lt;/a&gt;什么是反射？&lt;/h4&gt;&lt;p&gt;Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。&lt;br&gt;我感觉这个动态性，是大家使用反射的最重要的原因，我们可以通过反射并且根据自己的需求，动态的调用一个类的方法。&lt;/p&gt;
&lt;h4 id=&quot;怎么反射？&quot;&gt;&lt;a href=&quot;#怎么反射？&quot; class=&quot;headerlink&quot; title=&quot;怎么反射？&quot;&gt;&lt;/a&gt;怎么反射？&lt;/h4&gt;&lt;p&gt;反射最开始肯定是要先加载类，然后在剖析它的构造函数，属性，方法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA多态之upcast与downcast</title>
    <link href="http://yoursite.com/2019/11/04/JAVA%E5%A4%9A%E6%80%81%E4%B9%8Bupcast%E4%B8%8Edowncast%20/"/>
    <id>http://yoursite.com/2019/11/04/JAVA多态之upcast与downcast /</id>
    <published>2019-11-04T11:48:26.000Z</published>
    <updated>2020-04-23T10:54:28.866Z</updated>
    
    <content type="html"><![CDATA[<h5 id="upcast（向上转型）"><a href="#upcast（向上转型）" class="headerlink" title="upcast（向上转型）"></a>upcast（向上转型）</h5><p>我们都知道，父类与子类之间是is-a的关系，时常会见到类似下面的这种语句：<br><code>Person p = new Student();//Person是Student的父类</code><br>同时Student继承并重写了Person的方法，并且也增加了新的方法，<br>那么p调用的成员变量或者成员方法，到底是谁的呢？<br>为此我特地写了两个类，来验证，上代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name=&quot;person&quot;;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">public class Student extends Person&#123;</span><br><span class="line">    String name=&quot;student&quot;;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Student is running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Student is eating!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的两个类中可以看出一下几点：</p><ul><li>Person是Student的父类；</li><li>Student隐藏了Person的name属性；</li><li>Student重写（覆盖）了Person的run()方法；</li><li>Student新增了eat()方法。</li></ul><p>下面就让我们来执行一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Student();</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.bmp.ovh/imgs/2019/11/a8082bb07217df89.png" alt><br>所以我们可以得到结论：</p><ul><li>p调用的成员方法是父类的，而不是被修改后的</li><li>p调用的成员方法被Student修改后的</li></ul><p>还有一个重要的点是：</p><ul><li>p无法调用eat()方法，也就是说p无法调用子类新增的方法，它可调用的范围只在父类里存在的。</li></ul><h5 id="downcast（向下转型）"><a href="#downcast（向下转型）" class="headerlink" title="downcast（向下转型）"></a>downcast（向下转型）</h5><p>有时我需要使用子类新添的方法，就不得不进行downcast。<br>类似与下面这样的语句：<br><code>Student s = (Student) p;//p是上文中的一个Person对象</code><br>经过downcast，我们来测试一下，是否能够调用子类新添的eat()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person p = new Student();</span><br><span class="line">    Student s = (Student) p;</span><br><span class="line">    s.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.bmp.ovh/imgs/2019/11/e8aa0274ebf587b4.png" alt><br>说明eat()方法被执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;upcast（向上转型）&quot;&gt;&lt;a href=&quot;#upcast（向上转型）&quot; class=&quot;headerlink&quot; title=&quot;upcast（向上转型）&quot;&gt;&lt;/a&gt;upcast（向上转型）&lt;/h5&gt;&lt;p&gt;我们都知道，父类与子类之间是is-a的关系，时常会见到类似下面的这种语句：&lt;br&gt;&lt;code&gt;Person p = new Student();//Person是Student的父类&lt;/code&gt;&lt;br&gt;同时Student继承并重写了Person的方法，并且也增加了新的方法，&lt;br&gt;那么p调用的成员变量或者成员方法，到底是谁的呢？&lt;br&gt;为此我特地写了两个类，来验证，上代码：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
</feed>

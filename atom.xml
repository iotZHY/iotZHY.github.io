<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZHY的hexo博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-21T11:59:51.263Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iotZHY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>本地用户文件名的修改</title>
    <link href="http://yoursite.com/2020/02/21/%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2020/02/21/本地用户文件名的修改/</id>
    <published>2020-02-21T11:38:10.000Z</published>
    <updated>2020-02-21T11:59:51.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>本地用户名是我们出装系统时设置的，如果当初我们设置用户名是中文时，可能会遇到一下麻烦，对于一些不支持中文路径的软件，可能就安装不了，所以我最好再初装系统时，还是设置成英文字母为好。<a id="more"></a><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3></li><li>修改我们的注册表<ul><li>按win+r，输入regedit</li><li>按如下路径逐步点击<br><img src="https://i.bmp.ovh/imgs/2020/02/736d9cc8a0b8b5aa.png" alt></li><li>双击涂黄的文件，修改成你想改变的英文名字<br><img src="https://i.bmp.ovh/imgs/2020/02/b5bfe424ad21e2ed.png" alt></li></ul></li><li>重启<ul><li>重启后你会进入一个初始的桌面，不要慌张你的信息没有丢失。</li><li>进入c:\user目录下，修改用你以前的用户名命名的文件夹为你的新名字</li><li>重启电脑</li></ul></li><li>修改环境变量<ul><li>把环境变量中你之前用户名，改成现在的即可</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本地用户名是我们出装系统时设置的，如果当初我们设置用户名是中文时，可能会遇到一下麻烦，对于一些不支持中文路径的软件，可能就安装不了，所以我最好再初装系统时，还是设置成英文字母为好。
    
    </summary>
    
    
    
      <category term="win10" scheme="http://yoursite.com/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>交换机与ARP</title>
    <link href="http://yoursite.com/2020/02/19/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8EARP/"/>
    <id>http://yoursite.com/2020/02/19/交换机与ARP/</id>
    <published>2020-02-19T10:23:28.000Z</published>
    <updated>2020-02-21T12:03:29.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是交换机？"><a href="#什么是交换机？" class="headerlink" title="什么是交换机？"></a>什么是交换机？</h3><ul><li><p>交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机，它是以太网的核心，它工作在数据链路层，是基于MAC地址从端口到端口通信的，它不能识别IP地址，因此也叫二层交换机。</p><a id="more"></a><h3 id="它跟集线器的区别？"><a href="#它跟集线器的区别？" class="headerlink" title="它跟集线器的区别？"></a>它跟集线器的区别？</h3></li><li><p>最大的区别就在于，集线器工作在OSI模型的第一层，而交换机工作在二层。集线器就像它的名字那样，只起到了聚集的作用，它可以扩大网络，但它也加剧了信道内的碰撞，因为它的工作内容仅仅是把从这一端口收到信息广播到其他端口。而交换机它不光扩大了网络范围，也由于它使用的是单播的方式，所以它消除了碰撞，加快了网络速度。</p><h3 id="交换机怎样实现单播？"><a href="#交换机怎样实现单播？" class="headerlink" title="交换机怎样实现单播？"></a>交换机怎样实现单播？</h3></li><li><p>这得意与，它的MAC地址表，这个地址表记录交换机端口与MAC地址的映射关系（每一个端口对应一个计算机）。这个MAC地址表不是人为给交换机的，而是由交换机自己学习的。</p></li><li><p>学习过程也比较简单，就是在某一端口发送帧时，交换机会从该帧中获得源MAC，然后去自己的MAC地址表检索该端口，如果没有就直接添加，如果有则直接覆盖掉。交换机也会以固定的时间为周期来刷新MAC地址表。</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3></li><li><p>中文名称，地址解析协议，功能比较简单，就是把IP地址转换成MAC地址。它主要来维护本地主机的一个路由表。<br>让我们来简单模拟一下这个过程，A主机想要把信息发给局域网内的B主机，而A只知道B的IP而不知道B的MAC（局域网内只认识MAC），所以我们需要把IP转换成MAC，这是就用到了ARP。</p></li><li><p>这张图很能说明整个过程，只是A到B是广播，B到A是单播</p></li></ul><p><img src="https://ftp.bmp.ovh/imgs/2020/02/26d3c5b736e77011.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是交换机？&quot;&gt;&lt;a href=&quot;#什么是交换机？&quot; class=&quot;headerlink&quot; title=&quot;什么是交换机？&quot;&gt;&lt;/a&gt;什么是交换机？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机，它是以太网的核心，它工作在数据链路层，是基于MAC地址从端口到端口通信的，它不能识别IP地址，因此也叫二层交换机。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MES开发记录--环境配置</title>
    <link href="http://yoursite.com/2019/11/24/MES%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95--%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/11/24/MES开发记录--环境配置/</id>
    <published>2019-11-24T06:04:59.000Z</published>
    <updated>2019-11-26T16:46:47.936Z</updated>
    
    <content type="html"><![CDATA[<h5 id="开发所需："><a href="#开发所需：" class="headerlink" title="开发所需："></a>开发所需：</h5><ul><li>jdk （java的软件开发工具包）</li><li>Eclipse for java ee (java IDE，在里面进行主要的编码工作)</li><li>Tomcat （把自己的主机打造成服务器端）</li><li>Phpstudy （开启或关闭mysql数据库）</li><li>Navicat （对数据库可视化操作）<a id="more"></a></li></ul><hr><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li><p>jdk1.8<br>  官方下载地址：<br>  <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p></li><li><p>Eclipse for java ee<br>  1.去官网找最新版本<br>  <a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a><br>  <img src="https://i.bmp.ovh/imgs/2019/11/b7615a98a49a23dd.png" alt><br>  2.下载，换个安装源会快一点，不设置这部也可以。<br>  先点击Selcet Another Mirror，再选择一个安装源。<br>  <img src="https://ftp.bmp.ovh/imgs/2019/11/79d69700c93c361f.png" alt><br>  3.下载完成后，解压即可，eclipse是不用安装的，打开文件夹会找到eclipse.exe。</p></li><li><p>Tomcat<br>  官网下载地址：(7.0版本)<br>  <a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-70.cgi</a><br>  <img src="https://i.bmp.ovh/imgs/2019/11/5c85e0647d6eb81b.png" alt><br>  tomcat是不用安装的，下载到合适的位置，解压，看到有bin、webapp等文件夹即可</p></li><li><p>Phpstudy<br>  官网下载地址：<br>  <a href="https://m.xp.cn" target="_blank" rel="noopener">https://m.xp.cn</a></p></li><li><p>Navicat<br>  官网下载地址：<br>  <a href="https://www.pcsoft.com.cn/soft/20832.html?t=1523691320938" target="_blank" rel="noopener">https://www.pcsoft.com.cn/soft/20832.html?t=1523691320938</a></p></li><li><p>Spring<br>  下载地址：<br>  <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/libs-release-local/org/springframework/spring/</a><br>  我下载的是4.1.9版本的，比较老，但稳定。<br>  点进去后，选择黄色标注的文件下载<br>  <img src="https://ftp.bmp.ovh/imgs/2019/11/885f4cb724a414b8.png" alt><br>  下载完，解压后，文件的结构：</p><pre><code>docs：Spring相关文档，包括开发指南，API参考文档。libs：该文件夹下的jar分为三类：Spring框架class文件的jar包；Spring框架源文件的压缩包，文件名以-source结尾；Spring框架API文档的压缩包，文件名以-javadoc结尾。schemas：该文件下包含了Spring各种配置文件的XML Schema文档。readme.txt,notice.txt,license.txt：说明性文档</code></pre><p>  另外：spring的核心容器必须依赖于common-logging的jar包<br>  网站：<br>  <a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p></li></ul><hr><h6 id="Eclipse环境配置"><a href="#Eclipse环境配置" class="headerlink" title="Eclipse环境配置"></a>Eclipse环境配置</h6><ul><li>配置tomcat server</li><li>配置jdk</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;开发所需：&quot;&gt;&lt;a href=&quot;#开发所需：&quot; class=&quot;headerlink&quot; title=&quot;开发所需：&quot;&gt;&lt;/a&gt;开发所需：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;jdk （java的软件开发工具包）&lt;/li&gt;
&lt;li&gt;Eclipse for java ee (java IDE，在里面进行主要的编码工作)&lt;/li&gt;
&lt;li&gt;Tomcat （把自己的主机打造成服务器端）&lt;/li&gt;
&lt;li&gt;Phpstudy （开启或关闭mysql数据库）&lt;/li&gt;
&lt;li&gt;Navicat （对数据库可视化操作）
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JAVA高级特性 --反射</title>
    <link href="http://yoursite.com/2019/11/15/JAVA%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/11/15/JAVA高级特性-反射/</id>
    <published>2019-11-15T14:37:26.000Z</published>
    <updated>2020-02-21T12:17:54.597Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。<br>我感觉这个动态性，是大家使用反射的最重要的原因，我们可以通过反射并且根据自己的需求，动态的调用一个类的方法。</p><h4 id="怎么反射？"><a href="#怎么反射？" class="headerlink" title="怎么反射？"></a>怎么反射？</h4><p>反射最开始肯定是要先加载类，然后在剖析它的构造函数，属性，方法</p><a id="more"></a><h5 id="加载类的三种方法"><a href="#加载类的三种方法" class="headerlink" title="加载类的三种方法"></a>加载类的三种方法</h5><ol><li><p>使用Class类的静态方法forName()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //forName里面使用完整类的路径</span><br><span class="line">    Class clazz =Class.forName(&quot;exp.Person&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用方法getClass()，前提要新建一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = new Person().getClass();</span><br><span class="line">//在非静态方法里，也可以使用this关键字</span><br></pre></td></tr></table></figure></li><li><p>使用这个类的静态变量class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line">//这个方式简单粗暴个人很喜欢</span><br></pre></td></tr></table></figure></li></ol><h5 id="解剖类的方法"><a href="#解剖类的方法" class="headerlink" title="解剖类的方法"></a>解剖类的方法</h5><ol><li><p>public Constructor getConstructor() /构造函数<br>//参数为可变的，指定需要的构造函数的参数类型的class类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor c = class.getConstructor(String.class);</span><br><span class="line">c.newInstance();//创建一个对象</span><br></pre></td></tr></table></figure></li><li><p>public Method getMethod() //方法</p></li><li><p>public Field getField() //字段，成员方法，只返回public修饰的</p><h6 id="前面三种方式只能返回，修饰符是public的成员"><a href="#前面三种方式只能返回，修饰符是public的成员" class="headerlink" title="//前面三种方式只能返回，修饰符是public的成员"></a>//前面三种方式只能返回，修饰符是public的成员</h6></li><li><p>public Constructor getDeclaredConstructor() /构造函数</p></li><li><p>public Method getDeclaredMethod() //方法</p></li><li><p>public Field getDeclaredField() //字段，成员方法除public外</p></li></ol><ul><li>可以不用获得构造函数直接获得对象,但只限于无参的构造函数<br><code>clazz.newInstance()</code></li><li>私有的成员只能在内部被访问，但是反射可以实现访问私有成员,使用<br><code>setAccessible（true）;</code></li><li>执行方法: invoke()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = new Person().getClass();</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = clazz.getMethod(&quot;run&quot;);</span><br><span class="line">            Object obj = method.invoke(clazz.newInstance());</span><br><span class="line">            System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是反射？&quot;&gt;&lt;a href=&quot;#什么是反射？&quot; class=&quot;headerlink&quot; title=&quot;什么是反射？&quot;&gt;&lt;/a&gt;什么是反射？&lt;/h4&gt;&lt;p&gt;Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。&lt;br&gt;我感觉这个动态性，是大家使用反射的最重要的原因，我们可以通过反射并且根据自己的需求，动态的调用一个类的方法。&lt;/p&gt;
&lt;h4 id=&quot;怎么反射？&quot;&gt;&lt;a href=&quot;#怎么反射？&quot; class=&quot;headerlink&quot; title=&quot;怎么反射？&quot;&gt;&lt;/a&gt;怎么反射？&lt;/h4&gt;&lt;p&gt;反射最开始肯定是要先加载类，然后在剖析它的构造函数，属性，方法&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JAVA多态之upcast与downcast</title>
    <link href="http://yoursite.com/2019/11/04/JAVA%E5%A4%9A%E6%80%81%E4%B9%8Bupcast%E4%B8%8Edowncast%20/"/>
    <id>http://yoursite.com/2019/11/04/JAVA多态之upcast与downcast /</id>
    <published>2019-11-04T11:48:26.000Z</published>
    <updated>2019-11-17T07:03:49.186Z</updated>
    
    <content type="html"><![CDATA[<h5 id="upcast（向上转型）"><a href="#upcast（向上转型）" class="headerlink" title="upcast（向上转型）"></a>upcast（向上转型）</h5><p>我们都知道，父类与子类之间是is-a的关系，时常会见到类似下面的这种语句：<br><code>Person p = new Student();//Person是Student的父类</code><br>同时Student继承并重写了Person的方法，并且也增加了新的方法，<br>那么p调用的成员变量或者成员方法，到底是谁的呢？<br>为此我特地写了两个类，来验证，上代码：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name=&quot;person&quot;;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">public class Student extends Person&#123;</span><br><span class="line">    String name=&quot;student&quot;;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Student is running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Student is eating!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的两个类中可以看出一下几点：</p><ul><li>Person是Student的父类；</li><li>Student隐藏了Person的name属性；</li><li>Student重写（覆盖）了Person的run()方法；</li><li>Student新增了eat()方法。</li></ul><p>下面就让我们来执行一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Student();</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.bmp.ovh/imgs/2019/11/a8082bb07217df89.png" alt><br>所以我们可以得到结论：</p><ul><li>p调用的成员方法是父类的，而不是被修改后的</li><li>p调用的成员方法被Student修改后的</li></ul><p>还有一个重要的点是：</p><ul><li>p无法调用eat()方法，也就是说p无法调用子类新增的方法，它可调用的范围只在父类里存在的。</li></ul><h5 id="downcast（向下转型）"><a href="#downcast（向下转型）" class="headerlink" title="downcast（向下转型）"></a>downcast（向下转型）</h5><p>有时我需要使用子类新添的方法，就不得不进行downcast。<br>类似与下面这样的语句：<br><code>Student s = (Student) p;//p是上文中的一个Person对象</code><br>经过downcast，我们来测试一下，是否能够调用子类新添的eat()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person p = new Student();</span><br><span class="line">    Student s = (Student) p;</span><br><span class="line">    s.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.bmp.ovh/imgs/2019/11/e8aa0274ebf587b4.png" alt><br>说明eat()方法被执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;upcast（向上转型）&quot;&gt;&lt;a href=&quot;#upcast（向上转型）&quot; class=&quot;headerlink&quot; title=&quot;upcast（向上转型）&quot;&gt;&lt;/a&gt;upcast（向上转型）&lt;/h5&gt;&lt;p&gt;我们都知道，父类与子类之间是is-a的关系，时常会见到类似下面的这种语句：&lt;br&gt;&lt;code&gt;Person p = new Student();//Person是Student的父类&lt;/code&gt;&lt;br&gt;同时Student继承并重写了Person的方法，并且也增加了新的方法，&lt;br&gt;那么p调用的成员变量或者成员方法，到底是谁的呢？&lt;br&gt;为此我特地写了两个类，来验证，上代码：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>写hexo博客的基本知识</title>
    <link href="http://yoursite.com/2019/10/17/%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/10/17/写hexo博客的基本知识/</id>
    <published>2019-10-17T15:03:02.000Z</published>
    <updated>2019-11-04T12:15:55.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最常用到的hexo命令："><a href="#最常用到的hexo命令：" class="headerlink" title="最常用到的hexo命令："></a>最常用到的hexo命令：</h4><p>（以下命令作用在你自己的博客所在文件夹下）</p><h6 id="hexo-n-“文章名”"><a href="#hexo-n-“文章名”" class="headerlink" title="hexo n “文章名”"></a>hexo n “文章名”</h6><ul><li>hexo new 的简写</li><li>创建一个以md结尾的文件，可以使用markdown编写</li></ul><h6 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h6><ul><li>清除缓存文件 db.json 和已生成的静态文件 public </li><li>网站显示异常时可以执行这个命令试试</li></ul><h6 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h6><ul><li>hexo generate 的简写</li><li>生成网站静态文件到默认设置的 public 文件夹</li><li>如果使用自动部署，不需要先执行该命令</li></ul><h6 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h6><ul><li>hexo server 的简写</li><li>将自己的blog运行在本地，可以通过 localhost:4000 访问</li></ul><h6 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h6><ul><li>hexo deploy 的简写</li><li>自动生成静态网页并部署到远端，我的blog是部署到了github上<a id="more"></a></li></ul><hr><h4 id="Markdown的基本语法"><a href="#Markdown的基本语法" class="headerlink" title="Markdown的基本语法"></a>Markdown的基本语法</h4><h6 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h6><blockquote><p>支持多级标题，以#的数量表示标题的级数，级数越高，标题的字体越小。</p></blockquote><h6 id="二-字体格式"><a href="#二-字体格式" class="headerlink" title="二.字体格式"></a>二.字体格式</h6><ul><li><p><strong>倾斜</strong></p><p>  <code>文字左右两边各有一个*</code></p></li><li><p><strong>加粗</strong><br>  <code>文字左右两边各有两个*</code> </p></li><li><p><strong>倾斜加粗</strong></p><p>  <code>文字左右两边各有三个*</code></p></li><li><p><strong>删除线</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文字左右两边各有~~</span><br><span class="line">例：~~zhy~~</span><br></pre></td></tr></table></figure></li></ul><h6 id="三-分割线"><a href="#三-分割线" class="headerlink" title="三.分割线"></a>三.分割线</h6><ul><li><p>三个或者三个以上的 - 或者 * 都可以。</p><h6 id="四-图片"><a href="#四-图片" class="headerlink" title="四.图片"></a>四.图片</h6><p><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</code></p></li><li><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</p></li><li><p>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><h6 id="五-超链接"><a href="#五-超链接" class="headerlink" title="五.超链接"></a>五.超链接</h6><p><code>[超链接名](超链接地址 &quot;超链接title&quot;)</code></p></li><li><p>和图片很相似，title可加可不加</p><h6 id="六-列表"><a href="#六-列表" class="headerlink" title="六.列表"></a>六.列表</h6></li><li><p>无序列表</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+列表内容</span><br><span class="line">+列表内容</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">+换成 - ，* 都可以</span><br><span class="line">注意：+与内容见有一个空格</span><br></pre></td></tr></table></figure><ul><li>有序列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><h6 id="七-代码"><a href="#七-代码" class="headerlink" title="七.代码"></a>七.代码</h6><ul><li>单行</li></ul><blockquote><p>使用两个 ` 包围代码，在esc键下边，用英文键盘打出</p></blockquote><ul><li>多行</li></ul><blockquote><p>要包裹的代码块左右两端用``` 包裹。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;最常用到的hexo命令：&quot;&gt;&lt;a href=&quot;#最常用到的hexo命令：&quot; class=&quot;headerlink&quot; title=&quot;最常用到的hexo命令：&quot;&gt;&lt;/a&gt;最常用到的hexo命令：&lt;/h4&gt;&lt;p&gt;（以下命令作用在你自己的博客所在文件夹下）&lt;/p&gt;
&lt;h6 id=&quot;hexo-n-“文章名”&quot;&gt;&lt;a href=&quot;#hexo-n-“文章名”&quot; class=&quot;headerlink&quot; title=&quot;hexo n “文章名”&quot;&gt;&lt;/a&gt;hexo n “文章名”&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo new 的简写&lt;/li&gt;
&lt;li&gt;创建一个以md结尾的文件，可以使用markdown编写&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-clean&quot;&gt;&lt;a href=&quot;#hexo-clean&quot; class=&quot;headerlink&quot; title=&quot;hexo clean&quot;&gt;&lt;/a&gt;hexo clean&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;清除缓存文件 db.json 和已生成的静态文件 public &lt;/li&gt;
&lt;li&gt;网站显示异常时可以执行这个命令试试&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-g&quot;&gt;&lt;a href=&quot;#hexo-g&quot; class=&quot;headerlink&quot; title=&quot;hexo g&quot;&gt;&lt;/a&gt;hexo g&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo generate 的简写&lt;/li&gt;
&lt;li&gt;生成网站静态文件到默认设置的 public 文件夹&lt;/li&gt;
&lt;li&gt;如果使用自动部署，不需要先执行该命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-s&quot;&gt;&lt;a href=&quot;#hexo-s&quot; class=&quot;headerlink&quot; title=&quot;hexo s&quot;&gt;&lt;/a&gt;hexo s&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo server 的简写&lt;/li&gt;
&lt;li&gt;将自己的blog运行在本地，可以通过 localhost:4000 访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-d&quot;&gt;&lt;a href=&quot;#hexo-d&quot; class=&quot;headerlink&quot; title=&quot;hexo d&quot;&gt;&lt;/a&gt;hexo d&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo deploy 的简写&lt;/li&gt;
&lt;li&gt;自动生成静态网页并部署到远端，我的blog是部署到了github上
    
    </summary>
    
    
    
      <category term="hexo,命令" scheme="http://yoursite.com/tags/hexo-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>chrome的插件安装</title>
    <link href="http://yoursite.com/2019/09/26/chrome%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/09/26/chrome的插件安装/</id>
    <published>2019-09-26T03:39:15.000Z</published>
    <updated>2019-09-26T05:31:15.541Z</updated>
    
    <content type="html"><![CDATA[<p>之前在安装chrome插件时踩了好多坑，但是今天在B站上看到了一个很好的视频教程，想看的同学<a href="https://www.bilibili.com/video/av53026948/?p=1" target="_blank" rel="noopener">点击这里</a></p><a id="more"></a><h4 id="简述过程"><a href="#简述过程" class="headerlink" title="简述过程"></a>简述过程</h4><h6 id="首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）"><a href="#首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）" class="headerlink" title="首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）"></a>首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）</h6><ul><li><a href="https://www.crx4chrome.com" target="_blank" rel="noopener">Crx4Chrome</a>(推荐大家使用))</li></ul><ul><li><a href="https://www.extfans.com" target="_blank" rel="noopener">Extfans</a>(这个网站会让大家关注他的公众号，还要验证码)</li></ul><h6 id="再介绍几个好用的插件"><a href="#再介绍几个好用的插件" class="headerlink" title="再介绍几个好用的插件"></a>再介绍几个好用的插件</h6><ul><li><p>Infinity 新标签页(Pro)    </p><p>  效果图：</p><p>  <img src="http://www.cnplugins.com/uploads/crximage/201504/www.cnplugins.com_dbfmnekepjoapopniengjbcpnbljalfg_2.jpg" alt="infinity"></p><ul><li>Adblock Plus -免费广告拦截程序</li></ul><h6 id="插件的下载与安装"><a href="#插件的下载与安装" class="headerlink" title="插件的下载与安装"></a>插件的下载与安装</h6><p>  下载就很简单，直接去上面给的网站去找自己喜欢的插件下载即可。</p><p>  在Crx4Chrome中会下载 .crx 文件，而在Extfans中会下载到一个压缩文件，就很烦。所以，下面会以Crx4Chrome为例演示。</p></li></ul><p>我这里事先准备好了，crx文件 </p><blockquote><p>1.把.crx后缀改为.zip或.7z<br>2.然后解压<br>3.打开chrome浏览器-&gt;更多工具-&gt;扩展程序<br><img src="https://ftp.bmp.ovh/imgs/2019/09/1586b85c2e5e1c7a.png" alt><br>4.打开右上角的开发者模式<br>5.点击左上角的“加载已解压的扩展程序”，选择我们刚才解压的文件<br><img src="https://ftp.bmp.ovh/imgs/2019/09/04cd940a6ec2903b.png" alt><br>6.这样我们就安装成功了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在安装chrome插件时踩了好多坑，但是今天在B站上看到了一个很好的视频教程，想看的同学&lt;a href=&quot;https://www.bilibili.com/video/av53026948/?p=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="插件安装, chrome" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85-chrome/"/>
    
  </entry>
  
  <entry>
    <title>C中的头文件</title>
    <link href="http://yoursite.com/2019/09/25/C%E4%B8%AD%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/09/25/C中的头文件/</id>
    <published>2019-09-25T15:05:23.000Z</published>
    <updated>2020-02-21T12:11:27.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最先了解的知识"><a href="#最先了解的知识" class="headerlink" title="最先了解的知识"></a>最先了解的知识</h3><ol><li>系统自带的头文件，用&lt;&gt;包含,自定义的头文件，用””包含； </li><li>#include 预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；</li><li>查找头文件方式：先从工程文件所在的文件夹开始查找，如果没找到，从系统默认路径查找&lt;&gt;的文件，直接从系统默认路径查找；</li><li>变量，函数可以重复定义，但不可以重复定义。<a id="more"></a></li></ol><hr><h3 id="头文件写法"><a href="#头文件写法" class="headerlink" title="头文件写法"></a>头文件写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MY_POINT </span><br><span class="line">#define MY_POINT </span><br><span class="line">... </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li>这类语句，用于控制#define 与 #endif之间的内容不被重复定义或插入。</li><li>#define与#endif之间可以写一下宏定义，函数定义，变量声明之类的。</li><li>我们有时写c程序时，也可以把所有的声明都放到一个头文件中，然后在源文件中 #include”xxx.h”,这样会使你的程序看上去更简洁。</li></ul><hr><h3 id="使用头文件的好处"><a href="#使用头文件的好处" class="headerlink" title="使用头文件的好处"></a>使用头文件的好处</h3><ol><li>头文件只是声明，不占内存空间；</li><li>头文件可以定义所用的函数列表，方便查阅你可以调用的函数；</li><li>调用了头文件，就等于赋予了调用某些函数的权限，可以很方便的调用系统的库函数和自己写的一些工具函数；</li><li>头文件可以定义很多宏定义，就是一些全局静态变量的定义，在这样的情况下，只要修改头文件的内容，程序<br>就可以做相应的修改，不用亲自跑到繁琐的代码内去搜索。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最先了解的知识&quot;&gt;&lt;a href=&quot;#最先了解的知识&quot; class=&quot;headerlink&quot; title=&quot;最先了解的知识&quot;&gt;&lt;/a&gt;最先了解的知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;系统自带的头文件，用&amp;lt;&amp;gt;包含,自定义的头文件，用””包含； &lt;/li&gt;
&lt;li&gt;#include 预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；&lt;/li&gt;
&lt;li&gt;查找头文件方式：先从工程文件所在的文件夹开始查找，如果没找到，从系统默认路径查找&amp;lt;&amp;gt;的文件，直接从系统默认路径查找；&lt;/li&gt;
&lt;li&gt;变量，函数可以重复定义，但不可以重复定义。
    
    </summary>
    
    
    
      <category term="c语言,随笔" scheme="http://yoursite.com/tags/c%E8%AF%AD%E8%A8%80-%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZHY的hexo博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-04T08:54:34.378Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>iotZHY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>i++与++i的实现</title>
    <link href="http://yoursite.com/2020/04/04/i-%E4%B8%8E-i%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/04/04/i-与-i的实现/</id>
    <published>2020-04-04T08:45:06.000Z</published>
    <updated>2020-04-04T08:54:34.378Z</updated>
    
    <content type="html"><![CDATA[<p>i++与++i都是从右向左结合的，i++有滞后性，会先赋值再加一，而++i会先加一再赋值。<br><a id="more"></a></p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li><p>i++的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">int</span>::<span class="keyword">operator</span>(<span class="keyword">int</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> oldValue = *<span class="keyword">this</span>;</span><br><span class="line">      ++(*<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;<span class="comment">// 因为返回的是拷贝的临时变量，所以不能是左值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>++i的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">int</span>::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">   *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>感觉看完后，有了更深刻的印象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;i++与++i都是从右向左结合的，i++有滞后性，会先赋值再加一，而++i会先加一再赋值。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言运算符优先级</title>
    <link href="http://yoursite.com/2020/04/04/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/04/04/C语言运算符优先级/</id>
    <published>2020-04-04T08:19:37.000Z</published>
    <updated>2020-04-04T08:37:54.353Z</updated>
    
    <content type="html"><![CDATA[<p>…………………….<br><a id="more"></a></p><table border="1" cellspacing="0" cellpadding="0" width="612"><tbody><tr><td><p align="center"><strong>优先级</strong></p></td><td><p align="center"><strong>运算符</strong></p></td><td><p align="center"><strong>名称或含义</strong></p></td><td><p align="center"><strong>使用形式</strong></p></td><td><p align="center"><strong>结合方向</strong></p></td><td><p align="center"><strong>说明</strong></p></td></tr><tr><td rowspan="4"><p align="center"><strong>1</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">[]</span></strong></p></td><td><p>数组下标</p></td><td><p>数组名[常量表达式]</p></td><td rowspan="4"><p align="center">左到右</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">()</span></strong></p></td><td><p>圆括号</p></td><td><p>(表达式）/函数名(形参表)</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">.</span></strong></p></td><td><p>成员选择（对象）</p></td><td><p>对象.成员名</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">-&gt;</span></strong></p></td><td><p>成员选择（指针）</p></td><td><p>对象指针-&gt;成员名</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="9"><p align="center"><strong>2</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">-</span></strong></p></td><td><p>负号运算符</p></td><td><p>-表达式</p></td><td rowspan="9"><p align="center"><strong><span style="COLOR: red">右到左</span></strong></p></td><td rowspan="7"><p align="center">单目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">~</span></strong></p></td><td><p>按位取反运算符</p></td><td><p>~表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">++</span></strong></p></td><td><p>自增运算符</p></td><td><p>++变量名/变量名++</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">--</span></strong></p></td><td><p>自减运算符</p></td><td><p>--变量名/变量名--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">*</span></strong></p></td><td><p>取值运算符</p></td><td><p>*指针变量</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&amp;</span></strong></p></td><td><p>取地址运算符</p></td><td><p>&amp;变量名</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">!</span></strong></p></td><td><p>逻辑非运算符</p></td><td><p>!表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">(</span><span style="COLOR: blue">类型</span><span style="COLOR: blue">)</span></strong></p></td><td><p>强制类型转换</p></td><td><p>(数据类型)表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">sizeof</span></strong></p></td><td><p>长度运算符</p></td><td><p>sizeof(表达式)</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="3"><p align="center"><strong>3</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">/</span></strong></p></td><td><p>除</p></td><td><p>表达式/表达式</p></td><td rowspan="3"><p align="center">左到右</p></td><td rowspan="3"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">*</span></strong></p></td><td><p>乘</p></td><td><p>表达式*表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">%</span></strong></p></td><td><p>余数（取模）</p></td><td><p>整型表达式%整型表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>4</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">+</span></strong></p></td><td><p>加</p></td><td><p>表达式+表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">-</span></strong></p></td><td><p>减</p></td><td><p>表达式-表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>5</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&lt;&lt;&nbsp;</span></strong></p></td><td><p>左移</p></td><td><p>变量&lt;&lt;表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&gt;&gt;&nbsp; </span></strong></p></td><td><p>右移</p></td><td><p>变量&gt;&gt;表达式</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td rowspan="4"><p align="center"><strong>6</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&gt;&nbsp;</span></strong></p></td><td><p>大于</p></td><td><p>表达式&gt;表达式</p></td><td rowspan="4"><p align="center">左到右</p></td><td rowspan="4"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&gt;=</span></strong></p></td><td><p>大于等于</p></td><td><p>表达式&gt;=表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&lt;&nbsp;</span></strong></p></td><td><p>小于</p></td><td><p>表达式&lt;表达式</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&lt;=</span></strong></p></td><td><p>小于等于</p></td><td><p>表达式&lt;=表达式</p></td></tr><tr><td rowspan="2"><p align="center"><strong>7</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">==</span></strong></p></td><td><p>等于</p></td><td><p>表达式==表达式</p></td><td rowspan="2"><p align="center">左到右</p></td><td rowspan="2"><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">！</span><span style="COLOR: blue">=</span></strong></p></td><td><p>不等于</p></td><td><p>表达式!= 表达式</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>8</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&amp;</span></strong></p></td><td><p>按位与</p></td><td><p>表达式&amp;表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>9</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">^</span></strong></p></td><td><p>按位异或</p></td><td><p>表达式^表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>10</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">|</span></strong></p></td><td><p>按位或</p></td><td><p>表达式|表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>11</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">&amp;&amp;</span></strong></p></td><td><p>逻辑与</p></td><td><p>表达式&amp;&amp;表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td><p align="center"><strong>12</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">||</span></strong></p></td><td><p>逻辑或</p></td><td><p>表达式||表达式</p></td><td><p align="center">左到右</p></td><td><p align="center">双目运算符</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>13</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">?:</span></strong></p></td><td><p>条件运算符</p></td><td><p>表达式1? </p><p>表达式2: 表达式3</p></td><td><p align="center"><strong><span style="COLOR: red">右到左</span></strong></p></td><td><p align="center"><span style="COLOR: red">三目运算符</span></p></td></tr><tr><td width="612" colspan="6"><p><span style="COLOR: red"></span>&nbsp;</p></td></tr><tr><td rowspan="11"><p align="center"><strong>14</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">=</span></strong></p></td><td><p>赋值运算符</p></td><td><p>变量=表达式</p></td><td rowspan="11"><p align="center"><strong><span style="COLOR: red">右到左</span></strong></p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">/=</span></strong></p></td><td><p>除后赋值</p></td><td><p>变量/=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">*=</span></strong></p></td><td><p>乘后赋值</p></td><td><p>变量*=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">%=</span></strong></p></td><td><p>取模后赋值</p></td><td><p>变量%=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">+=</span></strong></p></td><td><p>加后赋值</p></td><td><p>变量+=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">-=</span></strong></p></td><td><p>减后赋值</p></td><td><p>变量-=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&lt;&lt;=</span></strong></p></td><td><p>左移后赋值</p></td><td><p>变量&lt;&lt;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&gt;&gt;=</span></strong></p></td><td><p>右移后赋值</p></td><td><p>变量&gt;&gt;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">&amp;=</span></strong></p></td><td><p>按位与后赋值</p></td><td><p>变量&amp;=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">^=</span></strong></p></td><td><p>按位异或后赋值</p></td><td><p>变量^=表达式</p></td><td><p align="center">--</p></td></tr><tr><td><p align="center"><strong><span style="COLOR: blue">|=</span></strong></p></td><td><p>按位或后赋值</p></td><td><p>变量|=表达式</p></td><td><p align="center">--</p></td></tr><tr><td width="612" colspan="6"><p>&nbsp;</p></td></tr><tr><td><p align="center"><strong>15</strong></p></td><td><p align="center"><strong><span style="COLOR: blue">，</span></strong></p></td><td><p>逗号运算符</p></td><td><p>表达式,表达式,…</p></td><td><p align="center">左到右</p></td><td><p align="center">--</p></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;…………………….&lt;br&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>VSCode编写Vue的基础配置</title>
    <link href="http://yoursite.com/2020/04/04/VSCode%E7%BC%96%E5%86%99Vue%E7%9A%84%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/04/VSCode编写Vue的基础配置/</id>
    <published>2020-04-04T04:31:01.000Z</published>
    <updated>2020-04-04T04:41:27.148Z</updated>
    
    <content type="html"><![CDATA[<h5 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h5><ul><li>Vetur</li><li>ESLint</li><li>Prettier for VSCode</li><li>Auto Close Tag</li><li>Auto Rename Tag</li><li>Path Intellisense<a id="more"></a><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5>在工程下，创建.prettierrc文件，并添入<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"semi": false,//避免自动生成分号</span><br><span class="line">"singleQuote": true,//双引号变为单引号</span><br><span class="line">"editor.formatOnSave": true,</span><br><span class="line">"editor.defaultFormatter": "SimonSiefke.prettier-vscode",</span><br><span class="line">"trailingComma": "none"//避免自动生成逗号</span><br></pre></td></tr></table></figure></li></ul><p>在.eslintrc.js文件中的，rule项中，添入<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'prettier/prettier': 'off',</span><br><span class="line">'space-before-function-paren':0//避免因空格引起的错误</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Vetur&lt;/li&gt;
&lt;li&gt;ESLint&lt;/li&gt;
&lt;li&gt;Prettier for VSCode&lt;/li&gt;
&lt;li&gt;Auto Close Tag&lt;/li&gt;
&lt;li&gt;Auto Rename Tag&lt;/li&gt;
&lt;li&gt;Path Intellisense
    
    </summary>
    
    
    
      <category term="VSCode, Vue" scheme="http://yoursite.com/tags/VSCode-Vue/"/>
    
  </entry>
  
  <entry>
    <title>RSA加密原理</title>
    <link href="http://yoursite.com/2020/03/25/RSA%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/25/RSA加密原理/</id>
    <published>2020-03-25T03:00:23.000Z</published>
    <updated>2020-04-04T05:42:46.628Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RSA简单介绍"><a href="#RSA简单介绍" class="headerlink" title="RSA简单介绍"></a>RSA简单介绍</h4><p>RSA是 一种非对称加密算法，号称地球上最安全的加密算法，它建立的基础利用了大数素分解的困难性。<br><a id="more"></a></p><h4 id="RSA的组成"><a href="#RSA的组成" class="headerlink" title="RSA的组成"></a>RSA的组成</h4><ul><li>两个素数p，q</li><li>公钥$=（e,n）$</li><li>私钥$=（d,n）$</li><li>加密公式：$ 密文=明文^e mod n$</li><li>解密公式：$明文=密文^dmodn$<h4 id="需要先了解的知识"><a href="#需要先了解的知识" class="headerlink" title="需要先了解的知识"></a>需要先了解的知识</h4></li><li>$\varphi(n)$是欧拉函数，表示小于或等于n的正整数中与n互质的数的数目</li><li>当n是质数时，$\varphi(n)=n-1$</li><li>$\varphi(p<em>q)=\varphi(p) </em> \varphi(q)$</li><li>gcd(a,b)，计算a，b的最大公约数    </li><li><p>欧几里得算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展欧几里得算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exGcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r=exGcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">int</span> t=x;x=y;y=t-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="RSA过程"><a href="#RSA过程" class="headerlink" title="RSA过程"></a>RSA过程</h4><ol><li>生成两个素数 p，q</li><li>$n = p*q $</li><li>$\varphi(n)=(p-1)(q-1)$</li><li>生成e，要求  <ul><li>$1&lt;e&lt;\varphi(n)$</li><li>$gcd(\varphi(n),e)=1,即\varphi(n)与e互质$</li></ul></li><li>生成d，要求$ed=1 mod \varphi(n)$</li><li>最终把 $(e,n)$ 封装成公钥， $(d,n)$ 封装成私钥。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;RSA简单介绍&quot;&gt;&lt;a href=&quot;#RSA简单介绍&quot; class=&quot;headerlink&quot; title=&quot;RSA简单介绍&quot;&gt;&lt;/a&gt;RSA简单介绍&lt;/h4&gt;&lt;p&gt;RSA是 一种非对称加密算法，号称地球上最安全的加密算法，它建立的基础利用了大数素分解的困难性。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="网络安全，加密，RSA" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%EF%BC%8C%E5%8A%A0%E5%AF%86%EF%BC%8CRSA/"/>
    
  </entry>
  
  <entry>
    <title>android的Handler机制</title>
    <link href="http://yoursite.com/2020/03/24/android%E7%9A%84Handler%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/03/24/android的Handler机制/</id>
    <published>2020-03-24T10:36:00.000Z</published>
    <updated>2020-03-24T11:52:03.021Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Handler是什么？"><a href="#Handler是什么？" class="headerlink" title="Handler是什么？"></a>Handler是什么？</h4><p>在Android中，Handler被用来提供用于线程间通信，以确保线程通信安全（比如UI线程的安全）。包含四个组成部分：Message，Looper，MessageQueue，Handler，这四个组成部分构成了多线程中经典的“生产者————消费者模型”<br><a id="more"></a></p><ol><li>成员介绍 </li></ol><ul><li>Message：主要功能是进行消息的封装，同时可以指定消息的操作形式； </li><li>Looper：消息循环泵，用来为一个线程跑一个消息循环。每一个线程最多只可以拥有一个。 </li><li>MessageQueue：就是一个消息队列，存放消息的地方。每一个线程最多只可以拥有一个。 </li><li>Handler：消息的处理者，handler 负责将需要传递的信息封装成Message，发送给Looper，继而由Looper将Message放入MessageQueue中。当Looper对象看到MessageQueue中含有Message，就将其广播出去。该handler 对象收到该消息后，调用相应的handler 对象的handleMessage()方法对其进行处理。 </li></ul><ol><li>同线程各成员的关系及数量 </li></ol><ul><li>一个线程中只能有一个Looper，只能有一个MessageQueue，可以有多个Handler，多个Messge； </li><li>一个Looper只能维护唯一一个MessageQueue，可以接受多个Handler发来的消息； </li><li>一个Message只能属于唯一一个Handler； </li><li>同一个Handler只能处理自己发送给Looper的那些Message；<h4 id="为什么需要Handler？"><a href="#为什么需要Handler？" class="headerlink" title="为什么需要Handler？"></a>为什么需要Handler？</h4>最主要的原因是，在android中遵循单线程模型，子线程不允许访问UI，只有主线程才能访问UI。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable() &#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        myView.invalidate();    </span><br><span class="line">    &#125;            </span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ul><p>这样的代码在android中是不被允许的。</p><p>所以，当子线程想要更新UI时，就需要调用主线程中的Handler对象，通过Handler向主线程传递消息来通知更新UI。需要注意的是当Handler被创建时，它就与创建它的线程绑定，且定义Handler都用静态内部类的方式。</p><h4 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h4><ul><li><p>sendMessage(Message)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> currentPos  = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> duration = <span class="number">2</span>;</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putInt(<span class="string">"currentPos"</span>,currentPos);</span><br><span class="line">bundle.putInt(<span class="string">"duration"</span>,duration);</span><br><span class="line">Message msg  =  Message.obtain();</span><br><span class="line">msg.what = <span class="number">1</span>;<span class="comment">//标志消息的标志</span></span><br><span class="line">msg.setData(bundle);</span><br><span class="line">MainActivity.handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></li><li><p>post(Runnable)<br>post与sendMessage本质上很相似，首先，他们都可以传递信息，其次，通过阅读源码可以看出post就是把Runnable对象打包进了一个Message，然后使用sendMessageDelayed方法发送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        更新UI</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>handleMessage(Message)<br>处理Message，当Looper收到Message时，会自动调用它。</p><h4 id="Handler-通信机制"><a href="#Handler-通信机制" class="headerlink" title="Handler 通信机制"></a>Handler 通信机制</h4></li></ul><p><img src="https://i.bmp.ovh/imgs/2020/03/bf967fb7ee375441.png" alt></p><ul><li>创建Handler，并采用当前线程的Looper创建消息循环系统；</li><li>Handler通过sendMessage(Message)或Post(Runnable)发送消息，调用enqueueMessage把消息插入到消息链表中；</li><li>Looper循环检测消息队列中的消息，若有消息则取出该消息，并调用该消息持有的handler的dispatchMessage方法，回调到创建Handler线程中重写的handleMessage里执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Handler是什么？&quot;&gt;&lt;a href=&quot;#Handler是什么？&quot; class=&quot;headerlink&quot; title=&quot;Handler是什么？&quot;&gt;&lt;/a&gt;Handler是什么？&lt;/h4&gt;&lt;p&gt;在Android中，Handler被用来提供用于线程间通信，以确保线程通信安全（比如UI线程的安全）。包含四个组成部分：Message，Looper，MessageQueue，Handler，这四个组成部分构成了多线程中经典的“生产者————消费者模型”&lt;br&gt;
    
    </summary>
    
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="http://yoursite.com/2020/03/24/cookie%E5%92%8Csession/"/>
    <id>http://yoursite.com/2020/03/24/cookie和session/</id>
    <published>2020-03-24T02:43:44.000Z</published>
    <updated>2020-03-24T02:49:28.743Z</updated>
    
    <content type="html"><![CDATA[<p>………..<br><a id="more"></a></p><h5 id="一、cookie："><a href="#一、cookie：" class="headerlink" title="一、cookie："></a>一、cookie：</h5><p>在网站中，http请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。</p><h5 id="二、session"><a href="#二、session" class="headerlink" title="二、session:"></a>二、session:</h5><p>session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在本地浏览器，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。</p><h5 id="三、cookie和session结合使用："><a href="#三、cookie和session结合使用：" class="headerlink" title="三、cookie和session结合使用："></a>三、cookie和session结合使用：</h5><p>web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：</p><ol><li>存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。</li></ol><ol><li>将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式，但是也可以替换成其他形式。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;………..&lt;br&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="http://yoursite.com/2020/03/23/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/03/23/IDEA快捷键/</id>
    <published>2020-03-23T13:06:10.000Z</published>
    <updated>2020-03-24T02:47:35.396Z</updated>
    
    <content type="html"><![CDATA[<ul><li>ctrl+p: 查看函数参数情况</li><li>双击shift：搜索框</li><li>shift+回车：不管光标在哪，都会开始下一行</li><li>ctrl+shift+f12: 代码编辑框，最大化和还原</li><li>alt+ins：generate，可以产生geter，seter方法</li><li>ctrl+shift+v</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;ctrl+p: 查看函数参数情况&lt;/li&gt;
&lt;li&gt;双击shift：搜索框&lt;/li&gt;
&lt;li&gt;shift+回车：不管光标在哪，都会开始下一行&lt;/li&gt;
&lt;li&gt;ctrl+shift+f12: 代码编辑框，最大化和还原&lt;/li&gt;
&lt;li&gt;alt+ins：gener
      
    
    </summary>
    
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>git的简单使用</title>
    <link href="http://yoursite.com/2020/03/23/git%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/03/23/git的简单使用/</id>
    <published>2020-03-23T09:16:22.000Z</published>
    <updated>2020-04-03T10:38:52.592Z</updated>
    
    <content type="html"><![CDATA[<p>………..<br><a id="more"></a></p><h6 id="这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客"><a href="#这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客" class="headerlink" title="这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客"></a>这是一个简单的新建一个git仓库，并新建一个SSH密钥，最后上传自己项目的博客</h6><h4 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h4><p>这步很简单，不过多介绍，这是新建后的仓库的样子<br><img src="https://i.bmp.ovh/imgs/2020/03/48b87afcfa5ca51a.png" alt><br>这里给出了三种情况，第一种是你没有一个仓库；第二种是你已经有了一个本地的仓库；第三种是你要从其他仓库导入。<br>下面给出 了git的一些命令，我们完全可以把它copy过来在git的命令行里运行，但是在这之前如果没有ssh密钥的，需要新建一个。 </p><h4 id="新建SSH密钥"><a href="#新建SSH密钥" class="headerlink" title="新建SSH密钥"></a>新建SSH密钥</h4><p>点击setting，在里面找到Deploy keys，进入。<br><img src="https://i.bmp.ovh/imgs/2020/03/21a10ce1db4c346b.png" alt><br>因为，我们是 第一次使用，所以我需要在我本地，新建一个SSH密钥（新建一次即可，下次只需把这个密钥加到github）。点击“guide on deploy keys ”的 超链接跟随它的英文教程，一步步进行即可。<br>这是我对它教程的一个总结：</p><h6 id="创建一个新的SSH-key："><a href="#创建一个新的SSH-key：" class="headerlink" title="创建一个新的SSH key："></a>创建一个新的SSH key：</h6><ol><li>打开git bash</li><li>把下面的换成你的邮箱<br><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code> </li><li>下面会弹出对话，问你把密钥存在那个地方，一般直接回车存在C盘下面<br><code>Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):</code></li><li>下面会让你输入两次密码： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure></li></ol><h6 id="将SSH密钥添加到SSH-agent："><a href="#将SSH密钥添加到SSH-agent：" class="headerlink" title="将SSH密钥添加到SSH-agent："></a>将SSH密钥添加到SSH-agent：</h6><ol><li>打开ssh-agent<br><code>eval `ssh-agent` </code></li><li>加入<br><code>ssh-add ~/.ssh/id_rsa</code><h6 id="将ssh-key添加到github："><a href="#将ssh-key添加到github：" class="headerlink" title="将ssh-key添加到github："></a>将ssh-key添加到github：</h6></li><li>复制你的公钥<br><code>clip &lt; ~/.ssh/id_rsa.pub</code><br>也可以去存储密钥的文件直接复制id_rsa.pub里的内容</li><li>去到这个界面，点击“Add deploy key”<br><img src="https://i.bmp.ovh/imgs/2020/03/21a10ce1db4c346b.png" alt></li><li>填写tital，粘贴公钥，最后勾选“Allow write access”<br><img src="https://i.bmp.ovh/imgs/2020/03/8c7250f09bb4025f.png" alt></li></ol><h4 id="上传项目到github"><a href="#上传项目到github" class="headerlink" title="上传项目到github"></a>上传项目到github</h4><ol><li>到你想要上传项目的文件夹下<br><code>git init</code></li><li>可以为你的项目添加一个README<br><code>git add README.md</code></li><li>把上传到文件添加到缓存<br><code>git add .</code></li><li>查看git的状态<br><code>git status</code></li><li>提交,-m表示这次提交的备注<br><code>git commit -m &quot;first commit&quot;</code></li><li>添加远程主机<br><code>git remote add origin https://github.com/iotZHY/demo.git</code></li><li>push<br><code>git push -u origin master</code><h4 id="git命令的进阶学习（持续更新-）"><a href="#git命令的进阶学习（持续更新-）" class="headerlink" title="git命令的进阶学习（持续更新 ）"></a>git命令的进阶学习（持续更新 ）</h4></li></ol><ul><li>git commit —amend，也叫追加提交<br>情景：如果我们不小心提交了一版我们不满意的代码，并且给它推送到服务器了，在代码没被merge之前我们希望再修改一版满意的，而如果我们不想在服务器上abondon，它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中。</li><li>git pull:从远端拉取仓库，用于多人协作开发同步</li><li>git checkout -b 分支名:新建 一个分支，并切换到该分支</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;………..&lt;br&gt;
    
    </summary>
    
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>VPN与NAT</title>
    <link href="http://yoursite.com/2020/03/22/VPN%E4%B8%8ENAT/"/>
    <id>http://yoursite.com/2020/03/22/VPN与NAT/</id>
    <published>2020-03-22T02:33:40.000Z</published>
    <updated>2020-03-23T00:14:42.784Z</updated>
    
    <content type="html"><![CDATA[<h4 id="产生的原因："><a href="#产生的原因：" class="headerlink" title="产生的原因："></a>产生的原因：</h4><p>  由于ip地址的短缺，一个机构内可以申请到的ip地址数远远小于机构内的主机数，且也考虑到互联网的安全性，也不会把所有的主机接入互联网。为了解决问题 RFC1918指明了一些专用地址 ，这些地址只能用于一个机构内通讯 ，而不能用于互联网上的通讯。互联网上的路由器 对目的地址时专用地址的数据报一律不转发。专用地址是全球不唯一的，可重复的，自然也就无法连入互联网。一共有三个地址块：<br>（1）10.0.0.0——10.255.255.255<br>（2）172.16.0.0——172.31.255.255<br>（3）192.168.0.0——192.168.255.255<br><a id="more"></a></p><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>如果这些机构内的主机想要和互联网上的主机通信时该咋办呢？<br>如何连接两个异地的局域网？</p><h4 id="NAT技术："><a href="#NAT技术：" class="headerlink" title="NAT技术："></a>NAT技术：</h4><p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。<br>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p><ul><li>静态转换：IP地址对是一对一的，是一成不变的，某个私有IP地址只转换为某个公有IP地址。</li><li>动态转换：ip地址是多对多的，IP地址是不确定的，是随机的，所有被授权访问上Internet的私有IP地址可随机转换为任何指定的合法IP地址。动态转换可以使用多个合法外部地址集。当ISP提供的合法IP地址略少于网络内部的计算机数量时。可以采用动态转换的方式。</li><li>端口多路复用（PAT)是指改变外出数据包的源端口并进行端口转换，即端口地址转换。ip地址一对多，内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</li></ul><p>NAT工作流程：<br><img src="https://bkimg.cdn.bcebos.com/pic/0dd7912397dda144810a190cb2b7d0a20cf48608?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U3Mg==,xp_5,yp_5" alt></p><ul><li>第一步，局域网主机发出IP数据报（RES=192.168.1.100，DES=202.113.112.x），经过NAT网关时，NAT网关会根据它的映射表，修改数据报的源地址为一个合法的公网地址，这时的数据报变为（RES=202.113.113.x，DES=202.113.112.x），发送给服务器</li><li>第二部分，服务器收到后，以为给他发送消息的主机的ip为202.113.113.x，于是把请求到的数据发送给202.113.113.x，故发出的ip报文（RES=202.113.112.x，DES=202.113.113.x），经过NAT网关时，它把ip报文的目的地址根据映射表改为局域网内的ip，ip报文变为（RES=202.113.112.x，DES=192.168.1.100）</li></ul><h4 id="VPN技术："><a href="#VPN技术：" class="headerlink" title="VPN技术："></a>VPN技术：</h4><p>虚拟专用网络(VPN)的功能是：在公用网络上建立专用网络，进行加密通讯。通常情况下，VPN网关采取双网卡结构，外网卡使用公网IP接入Internet。 同一组网中，各个网络的网段不能相同。</p><p>VPN工作流程：<br><img src="https://i.bmp.ovh/imgs/2020/03/65d04d3db84455b9.png" alt></p><ol><li>网络一的VPN网关在接收到终端X发出的访问数据包时对其目标地址进行检查，如果目标地址属于网络二的地址，则将该数据包进行封装，封装的方式根据所采用的VPN技术不同而不同，同时VPN网关会构造一个新VPN数据包，并将封装后的原数据包作为VPN数据包的负载，VPN数据包的目标地址为网络二的VPN网关的外部地址。 </li><li>网络一的VPN网关将VPN数据包发送到Internet，由于VPN数据包的目标地址是网络二的VPN网关的外部地址，所以该数据包将被Internet中的路由正确地发送到网络二的VPN网关。 </li><li>网络二的VPN网关对接收到的数据包进行检查，如果发现该数据包是从网络一的VPN网关发出的，即可判定该数据包为VPN数据包，并对该数据包进行解包处理。解包的过程主要是先将VPN数据包的包头剥离，再将数据包反向处理还原成原始的数据包。 </li><li>网络二的VPN网关将还原后的原始数据包发送至目标终端B，由于原始数据包的目标地址是终端B的IP，所以该数据包能够被正确地发送到终端B。在终端B看来，它收到的数据包就和从终端A直接发过来的一样。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;产生的原因：&quot;&gt;&lt;a href=&quot;#产生的原因：&quot; class=&quot;headerlink&quot; title=&quot;产生的原因：&quot;&gt;&lt;/a&gt;产生的原因：&lt;/h4&gt;&lt;p&gt;  由于ip地址的短缺，一个机构内可以申请到的ip地址数远远小于机构内的主机数，且也考虑到互联网的安全性，也不会把所有的主机接入互联网。为了解决问题 RFC1918指明了一些专用地址 ，这些地址只能用于一个机构内通讯 ，而不能用于互联网上的通讯。互联网上的路由器 对目的地址时专用地址的数据报一律不转发。专用地址是全球不唯一的，可重复的，自然也就无法连入互联网。一共有三个地址块：&lt;br&gt;（1）10.0.0.0——10.255.255.255&lt;br&gt;（2）172.16.0.0——172.31.255.255&lt;br&gt;（3）192.168.0.0——192.168.255.255&lt;br&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>本地用户文件名的修改</title>
    <link href="http://yoursite.com/2020/02/21/%E6%9C%AC%E5%9C%B0%E7%94%A8%E6%88%B7%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
    <id>http://yoursite.com/2020/02/21/本地用户文件名的修改/</id>
    <published>2020-02-21T11:38:10.000Z</published>
    <updated>2020-02-21T11:59:51.263Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>本地用户名是我们出装系统时设置的，如果当初我们设置用户名是中文时，可能会遇到一下麻烦，对于一些不支持中文路径的软件，可能就安装不了，所以我最好再初装系统时，还是设置成英文字母为好。<a id="more"></a><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3></li><li>修改我们的注册表<ul><li>按win+r，输入regedit</li><li>按如下路径逐步点击<br><img src="https://i.bmp.ovh/imgs/2020/02/736d9cc8a0b8b5aa.png" alt></li><li>双击涂黄的文件，修改成你想改变的英文名字<br><img src="https://i.bmp.ovh/imgs/2020/02/b5bfe424ad21e2ed.png" alt></li></ul></li><li>重启<ul><li>重启后你会进入一个初始的桌面，不要慌张你的信息没有丢失。</li><li>进入c:\user目录下，修改用你以前的用户名命名的文件夹为你的新名字</li><li>重启电脑</li></ul></li><li>修改环境变量<ul><li>把环境变量中你之前用户名，改成现在的即可</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;本地用户名是我们出装系统时设置的，如果当初我们设置用户名是中文时，可能会遇到一下麻烦，对于一些不支持中文路径的软件，可能就安装不了，所以我最好再初装系统时，还是设置成英文字母为好。
    
    </summary>
    
    
    
      <category term="win10" scheme="http://yoursite.com/tags/win10/"/>
    
  </entry>
  
  <entry>
    <title>交换机与ARP</title>
    <link href="http://yoursite.com/2020/02/19/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8EARP/"/>
    <id>http://yoursite.com/2020/02/19/交换机与ARP/</id>
    <published>2020-02-19T10:23:28.000Z</published>
    <updated>2020-02-21T12:03:29.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是交换机？"><a href="#什么是交换机？" class="headerlink" title="什么是交换机？"></a>什么是交换机？</h3><ul><li>交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机，它是以太网的核心，它工作在数据链路层，是基于MAC地址从端口到端口通信的，它不能识别IP地址，因此也叫二层交换机。<a id="more"></a><h3 id="它跟集线器的区别？"><a href="#它跟集线器的区别？" class="headerlink" title="它跟集线器的区别？"></a>它跟集线器的区别？</h3></li><li>最大的区别就在于，集线器工作在OSI模型的第一层，而交换机工作在二层。集线器就像它的名字那样，只起到了聚集的作用，它可以扩大网络，但它也加剧了信道内的碰撞，因为它的工作内容仅仅是把从这一端口收到信息广播到其他端口。而交换机它不光扩大了网络范围，也由于它使用的是单播的方式，所以它消除了碰撞，加快了网络速度。<h3 id="交换机怎样实现单播？"><a href="#交换机怎样实现单播？" class="headerlink" title="交换机怎样实现单播？"></a>交换机怎样实现单播？</h3></li><li>这得意与，它的MAC地址表，这个地址表记录交换机端口与MAC地址的映射关系（每一个端口对应一个计算机）。这个MAC地址表不是人为给交换机的，而是由交换机自己学习的。</li><li>学习过程也比较简单，就是在某一端口发送帧时，交换机会从该帧中获得源MAC，然后去自己的MAC地址表检索该端口，如果没有就直接添加，如果有则直接覆盖掉。交换机也会以固定的时间为周期来刷新MAC地址表。<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3></li><li><p>中文名称，地址解析协议，功能比较简单，就是把IP地址转换成MAC地址。它主要来维护本地主机的一个路由表。<br>让我们来简单模拟一下这个过程，A主机想要把信息发给局域网内的B主机，而A只知道B的IP而不知道B的MAC（局域网内只认识MAC），所以我们需要把IP转换成MAC，这是就用到了ARP。</p></li><li><p>这张图很能说明整个过程，只是A到B是广播，B到A是单播</p></li></ul><p><img src="https://ftp.bmp.ovh/imgs/2020/02/26d3c5b736e77011.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是交换机？&quot;&gt;&lt;a href=&quot;#什么是交换机？&quot; class=&quot;headerlink&quot; title=&quot;什么是交换机？&quot;&gt;&lt;/a&gt;什么是交换机？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;交换机（Switch）意为“开关”是一种用于电（光）信号转发的网络设备，它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机，它是以太网的核心，它工作在数据链路层，是基于MAC地址从端口到端口通信的，它不能识别IP地址，因此也叫二层交换机。
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MES开发记录--环境配置</title>
    <link href="http://yoursite.com/2019/11/24/MES%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95--%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/11/24/MES开发记录--环境配置/</id>
    <published>2019-11-24T06:04:59.000Z</published>
    <updated>2019-11-26T16:46:47.936Z</updated>
    
    <content type="html"><![CDATA[<h5 id="开发所需："><a href="#开发所需：" class="headerlink" title="开发所需："></a>开发所需：</h5><ul><li>jdk （java的软件开发工具包）</li><li>Eclipse for java ee (java IDE，在里面进行主要的编码工作)</li><li>Tomcat （把自己的主机打造成服务器端）</li><li>Phpstudy （开启或关闭mysql数据库）</li><li>Navicat （对数据库可视化操作）<a id="more"></a></li></ul><hr><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><ul><li>jdk1.8<br>  官方下载地址：<br>  <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></li><li>Eclipse for java ee<br>  1.去官网找最新版本<br>  <a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a><br>  <img src="https://i.bmp.ovh/imgs/2019/11/b7615a98a49a23dd.png" alt><br>  2.下载，换个安装源会快一点，不设置这部也可以。<br>  先点击Selcet Another Mirror，再选择一个安装源。<br>  <img src="https://ftp.bmp.ovh/imgs/2019/11/79d69700c93c361f.png" alt><br>  3.下载完成后，解压即可，eclipse是不用安装的，打开文件夹会找到eclipse.exe。</li><li>Tomcat<br>  官网下载地址：(7.0版本)<br>  <a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-70.cgi</a><br>  <img src="https://i.bmp.ovh/imgs/2019/11/5c85e0647d6eb81b.png" alt><br>  tomcat是不用安装的，下载到合适的位置，解压，看到有bin、webapp等文件夹即可</li><li>Phpstudy<br>  官网下载地址：<br>  <a href="https://m.xp.cn" target="_blank" rel="noopener">https://m.xp.cn</a></li><li>Navicat<br>  官网下载地址：<br>  <a href="https://www.pcsoft.com.cn/soft/20832.html?t=1523691320938" target="_blank" rel="noopener">https://www.pcsoft.com.cn/soft/20832.html?t=1523691320938</a></li><li><p>Spring<br>  下载地址：<br>  <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/libs-release-local/org/springframework/spring/</a><br>  我下载的是4.1.9版本的，比较老，但稳定。<br>  点进去后，选择黄色标注的文件下载<br>  <img src="https://ftp.bmp.ovh/imgs/2019/11/885f4cb724a414b8.png" alt><br>  下载完，解压后，文件的结构：</p><pre><code>  docs：Spring相关文档，包括开发指南，API参考文档。  libs：该文件夹下的jar分为三类：Spring框架class文件的jar包；Spring框架源文件的压缩包，文件名以-source结尾；Spring框架API文档的压缩包，文件名以-javadoc结尾。  schemas：该文件下包含了Spring各种配置文件的XML Schema文档。  readme.txt,notice.txt,license.txt：说明性文档</code></pre><p>  另外：spring的核心容器必须依赖于common-logging的jar包<br>  网站：<br>  <a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p></li></ul><hr><h6 id="Eclipse环境配置"><a href="#Eclipse环境配置" class="headerlink" title="Eclipse环境配置"></a>Eclipse环境配置</h6><ul><li>配置tomcat server</li><li>配置jdk</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;开发所需：&quot;&gt;&lt;a href=&quot;#开发所需：&quot; class=&quot;headerlink&quot; title=&quot;开发所需：&quot;&gt;&lt;/a&gt;开发所需：&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;jdk （java的软件开发工具包）&lt;/li&gt;
&lt;li&gt;Eclipse for java ee (java IDE，在里面进行主要的编码工作)&lt;/li&gt;
&lt;li&gt;Tomcat （把自己的主机打造成服务器端）&lt;/li&gt;
&lt;li&gt;Phpstudy （开启或关闭mysql数据库）&lt;/li&gt;
&lt;li&gt;Navicat （对数据库可视化操作）
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JAVA高级特性 --反射</title>
    <link href="http://yoursite.com/2019/11/15/JAVA%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/11/15/JAVA高级特性-反射/</id>
    <published>2019-11-15T14:37:26.000Z</published>
    <updated>2020-02-21T12:17:54.597Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><p>Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。<br>我感觉这个动态性，是大家使用反射的最重要的原因，我们可以通过反射并且根据自己的需求，动态的调用一个类的方法。</p><h4 id="怎么反射？"><a href="#怎么反射？" class="headerlink" title="怎么反射？"></a>怎么反射？</h4><p>反射最开始肯定是要先加载类，然后在剖析它的构造函数，属性，方法<br><a id="more"></a></p><h5 id="加载类的三种方法"><a href="#加载类的三种方法" class="headerlink" title="加载类的三种方法"></a>加载类的三种方法</h5><ol><li><p>使用Class类的静态方法forName()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //forName里面使用完整类的路径</span><br><span class="line">    Class clazz =Class.forName(&quot;exp.Person&quot;);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用方法getClass()，前提要新建一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = new Person().getClass();</span><br><span class="line">//在非静态方法里，也可以使用this关键字</span><br></pre></td></tr></table></figure></li><li><p>使用这个类的静态变量class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line">//这个方式简单粗暴个人很喜欢</span><br></pre></td></tr></table></figure></li></ol><h5 id="解剖类的方法"><a href="#解剖类的方法" class="headerlink" title="解剖类的方法"></a>解剖类的方法</h5><ol><li><p>public Constructor getConstructor() /构造函数<br>//参数为可变的，指定需要的构造函数的参数类型的class类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor c = class.getConstructor(String.class);</span><br><span class="line">c.newInstance();//创建一个对象</span><br></pre></td></tr></table></figure></li><li><p>public Method getMethod() //方法</p></li><li>public Field getField() //字段，成员方法，只返回public修饰的<h6 id="前面三种方式只能返回，修饰符是public的成员"><a href="#前面三种方式只能返回，修饰符是public的成员" class="headerlink" title="//前面三种方式只能返回，修饰符是public的成员"></a>//前面三种方式只能返回，修饰符是public的成员</h6></li><li>public Constructor getDeclaredConstructor() /构造函数</li><li>public Method getDeclaredMethod() //方法</li><li>public Field getDeclaredField() //字段，成员方法除public外</li></ol><ul><li>可以不用获得构造函数直接获得对象,但只限于无参的构造函数<br><code>clazz.newInstance()</code></li><li>私有的成员只能在内部被访问，但是反射可以实现访问私有成员,使用<br><code>setAccessible（true）;</code></li><li>执行方法: invoke()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Class clazz = new Person().getClass();</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = clazz.getMethod(&quot;run&quot;);</span><br><span class="line">            Object obj = method.invoke(clazz.newInstance());</span><br><span class="line">            System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是反射？&quot;&gt;&lt;a href=&quot;#什么是反射？&quot; class=&quot;headerlink&quot; title=&quot;什么是反射？&quot;&gt;&lt;/a&gt;什么是反射？&lt;/h4&gt;&lt;p&gt;Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。&lt;br&gt;我感觉这个动态性，是大家使用反射的最重要的原因，我们可以通过反射并且根据自己的需求，动态的调用一个类的方法。&lt;/p&gt;
&lt;h4 id=&quot;怎么反射？&quot;&gt;&lt;a href=&quot;#怎么反射？&quot; class=&quot;headerlink&quot; title=&quot;怎么反射？&quot;&gt;&lt;/a&gt;怎么反射？&lt;/h4&gt;&lt;p&gt;反射最开始肯定是要先加载类，然后在剖析它的构造函数，属性，方法&lt;br&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JAVA多态之upcast与downcast</title>
    <link href="http://yoursite.com/2019/11/04/JAVA%E5%A4%9A%E6%80%81%E4%B9%8Bupcast%E4%B8%8Edowncast%20/"/>
    <id>http://yoursite.com/2019/11/04/JAVA多态之upcast与downcast /</id>
    <published>2019-11-04T11:48:26.000Z</published>
    <updated>2019-11-17T07:03:49.186Z</updated>
    
    <content type="html"><![CDATA[<h5 id="upcast（向上转型）"><a href="#upcast（向上转型）" class="headerlink" title="upcast（向上转型）"></a>upcast（向上转型）</h5><p>我们都知道，父类与子类之间是is-a的关系，时常会见到类似下面的这种语句：<br><code>Person p = new Student();//Person是Student的父类</code><br>同时Student继承并重写了Person的方法，并且也增加了新的方法，<br>那么p调用的成员变量或者成员方法，到底是谁的呢？<br>为此我特地写了两个类，来验证，上代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    String name=&quot;person&quot;;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I&apos;m running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package exp;</span><br><span class="line"></span><br><span class="line">public class Student extends Person&#123;</span><br><span class="line">    String name=&quot;student&quot;;</span><br><span class="line"></span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Student is running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Student is eating!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的两个类中可以看出一下几点：</p><ul><li>Person是Student的父类；</li><li>Student隐藏了Person的name属性；</li><li>Student重写（覆盖）了Person的run()方法；</li><li>Student新增了eat()方法。</li></ul><p>下面就让我们来执行一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Student();</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.bmp.ovh/imgs/2019/11/a8082bb07217df89.png" alt><br>所以我们可以得到结论：</p><ul><li>p调用的成员方法是父类的，而不是被修改后的</li><li>p调用的成员方法被Student修改后的</li></ul><p>还有一个重要的点是：</p><ul><li>p无法调用eat()方法，也就是说p无法调用子类新增的方法，它可调用的范围只在父类里存在的。</li></ul><h5 id="downcast（向下转型）"><a href="#downcast（向下转型）" class="headerlink" title="downcast（向下转型）"></a>downcast（向下转型）</h5><p>有时我需要使用子类新添的方法，就不得不进行downcast。<br>类似与下面这样的语句：<br><code>Student s = (Student) p;//p是上文中的一个Person对象</code><br>经过downcast，我们来测试一下，是否能够调用子类新添的eat()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person p = new Student();</span><br><span class="line">    Student s = (Student) p;</span><br><span class="line">    s.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://i.bmp.ovh/imgs/2019/11/e8aa0274ebf587b4.png" alt><br>说明eat()方法被执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;upcast（向上转型）&quot;&gt;&lt;a href=&quot;#upcast（向上转型）&quot; class=&quot;headerlink&quot; title=&quot;upcast（向上转型）&quot;&gt;&lt;/a&gt;upcast（向上转型）&lt;/h5&gt;&lt;p&gt;我们都知道，父类与子类之间是is-a的关系，时常会见到类似下面的这种语句：&lt;br&gt;&lt;code&gt;Person p = new Student();//Person是Student的父类&lt;/code&gt;&lt;br&gt;同时Student继承并重写了Person的方法，并且也增加了新的方法，&lt;br&gt;那么p调用的成员变量或者成员方法，到底是谁的呢？&lt;br&gt;为此我特地写了两个类，来验证，上代码：&lt;br&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>写hexo博客的基本知识</title>
    <link href="http://yoursite.com/2019/10/17/%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/10/17/写hexo博客的基本知识/</id>
    <published>2019-10-17T15:03:02.000Z</published>
    <updated>2019-11-04T12:15:55.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最常用到的hexo命令："><a href="#最常用到的hexo命令：" class="headerlink" title="最常用到的hexo命令："></a>最常用到的hexo命令：</h4><p>（以下命令作用在你自己的博客所在文件夹下）</p><h6 id="hexo-n-“文章名”"><a href="#hexo-n-“文章名”" class="headerlink" title="hexo n “文章名”"></a>hexo n “文章名”</h6><ul><li>hexo new 的简写</li><li>创建一个以md结尾的文件，可以使用markdown编写</li></ul><h6 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h6><ul><li>清除缓存文件 db.json 和已生成的静态文件 public </li><li>网站显示异常时可以执行这个命令试试</li></ul><h6 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h6><ul><li>hexo generate 的简写</li><li>生成网站静态文件到默认设置的 public 文件夹</li><li>如果使用自动部署，不需要先执行该命令</li></ul><h6 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h6><ul><li>hexo server 的简写</li><li>将自己的blog运行在本地，可以通过 localhost:4000 访问</li></ul><h6 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h6><ul><li>hexo deploy 的简写</li><li>自动生成静态网页并部署到远端，我的blog是部署到了github上<a id="more"></a></li></ul><hr><h4 id="Markdown的基本语法"><a href="#Markdown的基本语法" class="headerlink" title="Markdown的基本语法"></a>Markdown的基本语法</h4><h6 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h6><blockquote><p>支持多级标题，以#的数量表示标题的级数，级数越高，标题的字体越小。</p><h6 id="二-字体格式"><a href="#二-字体格式" class="headerlink" title="二.字体格式"></a>二.字体格式</h6><ul><li><strong>倾斜</strong></li></ul></blockquote><pre><code>`文字左右两边各有一个*`</code></pre><ul><li><strong>加粗</strong><br>  <code>文字左右两边各有两个*</code> </li><li><p><strong>倾斜加粗</strong></p><p>  <code>文字左右两边各有三个*</code></p></li><li><strong>删除线</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文字左右两边各有~~</span><br><span class="line">例：~~zhy~~</span><br></pre></td></tr></table></figure></li></ul><h6 id="三-分割线"><a href="#三-分割线" class="headerlink" title="三.分割线"></a>三.分割线</h6><ul><li><p>三个或者三个以上的 - 或者 * 都可以。</p><h6 id="四-图片"><a href="#四-图片" class="headerlink" title="四.图片"></a>四.图片</h6><p><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)</code></p></li><li><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</p></li><li>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<h6 id="五-超链接"><a href="#五-超链接" class="headerlink" title="五.超链接"></a>五.超链接</h6><code>[超链接名](超链接地址 &quot;超链接title&quot;)</code></li><li>和图片很相似，title可加可不加<h6 id="六-列表"><a href="#六-列表" class="headerlink" title="六.列表"></a>六.列表</h6></li><li>无序列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+列表内容</span><br><span class="line">+列表内容</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">+换成 - ，* 都可以</span><br><span class="line">注意：+与内容见有一个空格</span><br></pre></td></tr></table></figure><ul><li>有序列表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><h6 id="七-代码"><a href="#七-代码" class="headerlink" title="七.代码"></a>七.代码</h6><ul><li>单行</li></ul><blockquote><p>使用两个 ` 包围代码，在esc键下边，用英文键盘打出</p></blockquote><ul><li>多行</li></ul><blockquote><p>要包裹的代码块左右两端用``` 包裹。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;最常用到的hexo命令：&quot;&gt;&lt;a href=&quot;#最常用到的hexo命令：&quot; class=&quot;headerlink&quot; title=&quot;最常用到的hexo命令：&quot;&gt;&lt;/a&gt;最常用到的hexo命令：&lt;/h4&gt;&lt;p&gt;（以下命令作用在你自己的博客所在文件夹下）&lt;/p&gt;
&lt;h6 id=&quot;hexo-n-“文章名”&quot;&gt;&lt;a href=&quot;#hexo-n-“文章名”&quot; class=&quot;headerlink&quot; title=&quot;hexo n “文章名”&quot;&gt;&lt;/a&gt;hexo n “文章名”&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo new 的简写&lt;/li&gt;
&lt;li&gt;创建一个以md结尾的文件，可以使用markdown编写&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-clean&quot;&gt;&lt;a href=&quot;#hexo-clean&quot; class=&quot;headerlink&quot; title=&quot;hexo clean&quot;&gt;&lt;/a&gt;hexo clean&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;清除缓存文件 db.json 和已生成的静态文件 public &lt;/li&gt;
&lt;li&gt;网站显示异常时可以执行这个命令试试&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-g&quot;&gt;&lt;a href=&quot;#hexo-g&quot; class=&quot;headerlink&quot; title=&quot;hexo g&quot;&gt;&lt;/a&gt;hexo g&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo generate 的简写&lt;/li&gt;
&lt;li&gt;生成网站静态文件到默认设置的 public 文件夹&lt;/li&gt;
&lt;li&gt;如果使用自动部署，不需要先执行该命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-s&quot;&gt;&lt;a href=&quot;#hexo-s&quot; class=&quot;headerlink&quot; title=&quot;hexo s&quot;&gt;&lt;/a&gt;hexo s&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo server 的简写&lt;/li&gt;
&lt;li&gt;将自己的blog运行在本地，可以通过 localhost:4000 访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;hexo-d&quot;&gt;&lt;a href=&quot;#hexo-d&quot; class=&quot;headerlink&quot; title=&quot;hexo d&quot;&gt;&lt;/a&gt;hexo d&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;hexo deploy 的简写&lt;/li&gt;
&lt;li&gt;自动生成静态网页并部署到远端，我的blog是部署到了github上
    
    </summary>
    
    
    
      <category term="hexo,命令" scheme="http://yoursite.com/tags/hexo-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>chrome的插件安装</title>
    <link href="http://yoursite.com/2019/09/26/chrome%E7%9A%84%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/09/26/chrome的插件安装/</id>
    <published>2019-09-26T03:39:15.000Z</published>
    <updated>2019-09-26T05:31:15.541Z</updated>
    
    <content type="html"><![CDATA[<p>之前在安装chrome插件时踩了好多坑，但是今天在B站上看到了一个很好的视频教程，想看的同学<a href="https://www.bilibili.com/video/av53026948/?p=1" target="_blank" rel="noopener">点击这里</a><br><a id="more"></a></p><h4 id="简述过程"><a href="#简述过程" class="headerlink" title="简述过程"></a>简述过程</h4><h6 id="首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）"><a href="#首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）" class="headerlink" title="首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）"></a>首先给大家介绍两个比较好的chrome插件网站（推荐给不能使用谷歌搜索的小伙伴）</h6><ul><li><a href="https://www.crx4chrome.com" target="_blank" rel="noopener">Crx4Chrome</a>(推荐大家使用))</li></ul><ul><li><a href="https://www.extfans.com" target="_blank" rel="noopener">Extfans</a>(这个网站会让大家关注他的公众号，还要验证码)</li></ul><h6 id="再介绍几个好用的插件"><a href="#再介绍几个好用的插件" class="headerlink" title="再介绍几个好用的插件"></a>再介绍几个好用的插件</h6><ul><li><p>Infinity 新标签页(Pro)    </p><p>  效果图：</p><p>  <img src="http://www.cnplugins.com/uploads/crximage/201504/www.cnplugins.com_dbfmnekepjoapopniengjbcpnbljalfg_2.jpg" alt="infinity"></p><ul><li>Adblock Plus -免费广告拦截程序</li></ul><h6 id="插件的下载与安装"><a href="#插件的下载与安装" class="headerlink" title="插件的下载与安装"></a>插件的下载与安装</h6><p>  下载就很简单，直接去上面给的网站去找自己喜欢的插件下载即可。</p><p>  在Crx4Chrome中会下载 .crx 文件，而在Extfans中会下载到一个压缩文件，就很烦。所以，下面会以Crx4Chrome为例演示。</p></li></ul><p>我这里事先准备好了，crx文件 </p><blockquote><p>1.把.crx后缀改为.zip或.7z<br>2.然后解压<br>3.打开chrome浏览器-&gt;更多工具-&gt;扩展程序<br><img src="https://ftp.bmp.ovh/imgs/2019/09/1586b85c2e5e1c7a.png" alt><br>4.打开右上角的开发者模式<br>5.点击左上角的“加载已解压的扩展程序”，选择我们刚才解压的文件<br><img src="https://ftp.bmp.ovh/imgs/2019/09/04cd940a6ec2903b.png" alt><br>6.这样我们就安装成功了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在安装chrome插件时踩了好多坑，但是今天在B站上看到了一个很好的视频教程，想看的同学&lt;a href=&quot;https://www.bilibili.com/video/av53026948/?p=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击这里&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
    
      <category term="插件安装, chrome" scheme="http://yoursite.com/tags/%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85-chrome/"/>
    
  </entry>
  
  <entry>
    <title>C中的头文件</title>
    <link href="http://yoursite.com/2019/09/25/C%E4%B8%AD%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/09/25/C中的头文件/</id>
    <published>2019-09-25T15:05:23.000Z</published>
    <updated>2020-02-21T12:11:27.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最先了解的知识"><a href="#最先了解的知识" class="headerlink" title="最先了解的知识"></a>最先了解的知识</h3><ol><li>系统自带的头文件，用&lt;&gt;包含,自定义的头文件，用””包含； </li><li><h1 id="include-预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；"><a href="#include-预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；" class="headerlink" title="include 预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；"></a>include 预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；</h1></li><li>查找头文件方式：先从工程文件所在的文件夹开始查找，如果没找到，从系统默认路径查找&lt;&gt;的文件，直接从系统默认路径查找；</li><li>变量，函数可以重复定义，但不可以重复定义。<a id="more"></a></li></ol><hr><h3 id="头文件写法"><a href="#头文件写法" class="headerlink" title="头文件写法"></a>头文件写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MY_POINT </span><br><span class="line">#define MY_POINT </span><br><span class="line">... </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li>这类语句，用于控制#define 与 #endif之间的内容不被重复定义或插入。</li><li><h1 id="define与-endif之间可以写一下宏定义，函数定义，变量声明之类的。"><a href="#define与-endif之间可以写一下宏定义，函数定义，变量声明之类的。" class="headerlink" title="define与#endif之间可以写一下宏定义，函数定义，变量声明之类的。"></a>define与#endif之间可以写一下宏定义，函数定义，变量声明之类的。</h1></li><li>我们有时写c程序时，也可以把所有的声明都放到一个头文件中，然后在源文件中 #include”xxx.h”,这样会使你的程序看上去更简洁。</li></ul><hr><h3 id="使用头文件的好处"><a href="#使用头文件的好处" class="headerlink" title="使用头文件的好处"></a>使用头文件的好处</h3><ol><li>头文件只是声明，不占内存空间；</li><li>头文件可以定义所用的函数列表，方便查阅你可以调用的函数；</li><li>调用了头文件，就等于赋予了调用某些函数的权限，可以很方便的调用系统的库函数和自己写的一些工具函数；</li><li>头文件可以定义很多宏定义，就是一些全局静态变量的定义，在这样的情况下，只要修改头文件的内容，程序<br>就可以做相应的修改，不用亲自跑到繁琐的代码内去搜索。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最先了解的知识&quot;&gt;&lt;a href=&quot;#最先了解的知识&quot; class=&quot;headerlink&quot; title=&quot;最先了解的知识&quot;&gt;&lt;/a&gt;最先了解的知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;系统自带的头文件，用&amp;lt;&amp;gt;包含,自定义的头文件，用””包含； &lt;/li&gt;
&lt;li&gt;&lt;h1 id=&quot;include-预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；&quot;&gt;&lt;a href=&quot;#include-预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；&quot; class=&quot;headerlink&quot; title=&quot;include 预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；&quot;&gt;&lt;/a&gt;include 预处理指令，编译阶段运行把头文件中所有的代码制过来进行单纯的替换，不检查变量是否重定义的；&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;查找头文件方式：先从工程文件所在的文件夹开始查找，如果没找到，从系统默认路径查找&amp;lt;&amp;gt;的文件，直接从系统默认路径查找；&lt;/li&gt;
&lt;li&gt;变量，函数可以重复定义，但不可以重复定义。
    
    </summary>
    
    
    
      <category term="c语言,随笔" scheme="http://yoursite.com/tags/c%E8%AF%AD%E8%A8%80-%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
